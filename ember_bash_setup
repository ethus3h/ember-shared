#!/usr/bin/env bash

export emberSharedVersion='1.1.4.18'

# Allow problems to be caught within pipelines
set -o pipefail
if [[ -z "$PS1" ]]; then
    # Make ERR trap inherited, but only if the shell is non-interactive
    set -o errtrace
fi
#set -o nounset

# More verbose debugging
PS4='+($?) $BASH_SOURCE:$FUNCNAME:$LINENO:'
export PS4

# These may not be available on non-Wreathe systems
# shellcheck disable=SC1091
source crystallize-bash_setup &> /dev/null
# shellcheck disable=SC1091
source wreathe_bash_setup &> /dev/null
# shellcheck disable=SC1091
source bash_math_functions &> /dev/null
# shellcheck disable=SC1091
source egup-env &> /dev/null

die() {
    # shellcheck disable=SC1091
    source error-notify "$@"
    exit 1
}

embasename() {
    (
        path="$1"
        if [[ "$path" == "/" ]]; then
            printf "/"
            exit 0
        elif [[ "$1" =~ '/'$ ]]; then
            path="${path::${#path}-1}"
        fi
        printf "%s" "${path##*/}"
    )
}

emreadlink() {
    (
        cd "$(dirname "$1")" || exit 1
        setVariableToCommandOutput "basename" "embasename" "$1"
        printf "%s/%s" "$PWD" "${basename:?}"
    )
}

setVariableToCommandOutput() {
    if [[ "$1" == "emSetVariableToCommandOutputVar" ]]; then
        exit 1
    fi
    emSetVariableToCommandOutputVar="$1"
    shift
    save_traps="$(trap)"
    trap - ERR
    IFS= read -rd '' "$emSetVariableToCommandOutputVar" < <( "$@" )
    trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO}."' ERR
    eval "$save_traps"
}

print() {
    printf "%s" "$1"
}

eescape() {
    (
        export eescapeString="$1"
        # shellcheck disable=SC2016
        setVariableToCommandOutput temp bash -c 'perl -0777 -e '\''print(quotemeta($ENV{eescapeString}))'\'' | sed '\''s/\\$//'\'' | sed '\''s/\\\r/\r/'\'
        temp="${temp//$'\n'/'\n'}"
        printf "%s" "${temp//$'\r'/'\r'}"
    )
}

ereplace() {
    (
        # Perl returns 0 even if it can't find the file (without extra perl code), so test first.
        if [[ ! -e "$3" ]]; then
            die "The target file does not exist."
        fi
        setVariableToCommandOutput ereplaceFrom eescape "$1"
        export ereplaceFrom
        ereplaceTo="$2"
        export ereplaceTo
        perl -0777 -p -i -e 's/$ENV{ereplaceFrom}/$ENV{ereplaceTo}/g' "$3"
    )
}

readconf() {
    local key="$1"
    local file="$2"
    if [[ -z "$file" ]]; then
        file="$1"
        key=""
    fi
    readconfValue=()
    while IFS= read -r line; do
        if ! [[ "$line" =~ ^# ]]; then
            if [[ -z "$key" ]]; then
                readconfValue+=("$line")
            else
                if [[ "$(cut -f1 -d, <<< "$line")" == "$1" ]]; then
                    readconfValue+=("$(cut -f2- -d, <<< "$line")")
                fi
            fi
        fi
    done < "$2"
}

preadconf() {
    readconf "$@"
    print "${readconfValue[0]}"
}

ia() {
    if [[ "$1" == "upload" ]]; then
        (
            # Retry wrapper for ia to work around https://github.com/jjjake/internetarchive/issues/183
            wantsDelete="false"
            patternMatch="^--"
            newParams=()
            fileArgs=()
            iterCount=0
            for param in "$@"; do
                if [[ "$param" == "--delete" ]]; then
                    wantsDelete="true"
                    break
                fi
                if ! [[ "$param" =~ $patternMatch ]]; then
                    # Skip first two arguments ("upload" and identifier)
                    if [[ "$iterCount" == "0" ]]; then
                        iterCount=1
                    elif [[ "$iterCount" == "1" ]]; then
                        iterCount=2
                    else
                        fileArgs+=("$param")
                    fi
                fi
                newParams+=("$param")
            done
            retryCount=0
            succeeded="false"
            while [[ "$succeeded" != "true" && retryCount -lt 30 ]]; do
                # Use which to prevent calling this function again.
                "$(which ia)" "$@" && succeeded="true"
                retryCount=$(( retryCount + 1 ))
                if [[ "$retryCount" -gt 1 ]]; then
                    sleep 60
                fi
            done
            if [[ "$retryCount" -ge 30 ]]; then
                exit 1
            fi
            if [[ "$succeeded" == "true" ]] && [[ "$wantsDelete" == "true" ]]; then
                for file in "${fileArgs[@]}"; do
                    rm "${file:?}"
                done
            fi
        )
    else
        ia "$@"
    fi
}

urlencode() {
    local LANG=C
    for ((i=0; i < ${#1}; i++)); do
        if [[ ${1:$i:1} =~ ^[a-zA-Z0-9\.\~_-]$ ]]; then
            printf "${1:$i:1}"
        else
            printf '%%%02X' "'${1:$i:1}"
        fi
    done
}

urldecode() {
    local url_encoded="${1//+/ }"
    printf '%b' "${url_encoded//%/\\x}"
}

contains() {
    local e
    for e in "${@:2}"; do [[ "$e" == "$1" ]] && return 0; done
    return 1
}

allElementsEqual() {
    local e
    for e in "${@:2}"; do [[ "$e" == "$1" ]] || return 1; done
    return 0
}

join_by() {
    # from https://stackoverflow.com/questions/1527049/join-elements-of-an-array
    local d="$1"
    shift
    echo -n "$1"
    shift
    printf "%s" "${@/#/$d}"
}

pipecheck() {
    allElementsEqual "0" "$@" || die "A failure status was reported by a call to pipecheck, with the reported exit statuses $(join_by  "$@")"
}

trap 'error-notify "An error was reported on ${BASH_SOURCE[0]} line ${LINENO}."' ERR
