#!/usr/bin/env bash

export emberSharedVersion='1.1.4'

# Allow problems to be caught within pipelines
set -o pipefail

# More verbose debugging
PS4='+($?) $BASH_SOURCE:$FUNCNAME:$LINENO:'
export PS4

# These may not be available on non-Wreathe systems
# shellcheck disable=SC1091
source crystallize-bash_setup &> /dev/null
# shellcheck disable=SC1091
source wreathe_bash_setup &> /dev/null
# shellcheck disable=SC1091
source bash_math_functions &> /dev/null
# shellcheck disable=SC1091
source egup-env &> /dev/null

function die() {
    # shellcheck disable=SC1091
    source error-notify "$@"
    exit 1
}

function embasename() {
    (
        path="$1"
        if [[ "$path" == "/" ]]; then
            printf "/"
            exit 0
        elif [[ "$1" =~ '/'$ ]]; then
            path="${path::${#path}-1}"
        fi
        printf "%s" "${path##*/}"
    )
}

function emreadlink() {
    (
        cd "$(dirname "$1")" || exit 1
        setVariableToCommandOutput "basename" "embasename" "$1"
        printf "%s/%s" "$PWD" "${basename:?}"
    )
}

function setVariableToCommandOutput() {
    if [[ "$1" == "emSetVariableToCommandOutputVar" ]]; then
        exit 1
    fi
    emSetVariableToCommandOutputVar="$1"
    shift
    save_traps="$(trap)"
    trap - ERR
    IFS= read -rd '' "$emSetVariableToCommandOutputVar" < <( "$@" )
    trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO}."' ERR
    eval "$save_traps"
}

function print() {
    printf "%s" "$1"
}

function eescape() {
    (
        export eescapeString="$1"
        # shellcheck disable=SC2016
        setVariableToCommandOutput temp bash -c 'perl -0777 -e '\''print(quotemeta($ENV{eescapeString}))'\'' | sed '\''s/\\$//'\'' | sed '\''s/\\\r/\r/'\'
        temp="${temp//$'\n'/'\n'}"
        printf "%s" "${temp//$'\r'/'\r'}"
    )
}

function ereplace() {
    (
        # Perl returns 0 even if it can't find the file (without extra perl code), so test first.
        if [[ ! -e "$3" ]]; then
            die "The target file does not exist."
        fi
        setVariableToCommandOutput ereplaceFrom eescape "$1"
        export ereplaceFrom
        ereplaceTo="$2"
        export ereplaceTo
        perl -0777 -p -i -e 's/$ENV{ereplaceFrom}/$ENV{ereplaceTo}/g' "$3"
    )
}

function readconf() {
    local key="$1"
    local file="$2"
    if [[ -z "$file" ]]; then
        file="$1"
        key=""
    fi
    readconfValue=()
    while IFS= read -r line; do
        if ! [[ "$line" =~ ^# ]]; then
            if [[ -z "$key" ]]; then
                readconfValue+=("$line")
            else
                if [[ "$(cut -f1 -d, <<< "$line")" == "$1" ]]; then
                    readconfValue+=("$(cut -f2- -d, <<< "$line")")
                fi
            fi
        fi
    done < "$2"
}

function preadconf() {
    readconf "$@"
    print "${readconfValue[0]}"
}

function ia() {
    (
        # Retry wrapper for ia to work around https://github.com/jjjake/internetarchive/issues/183
        retryCount=0
        succeeded="false"
        while [[ "$succeeded" != "true" && retryCount -lt 30 ]]; do
            "$(which ia)" "$@" && succeeded="true"
            retryCount=$(( retryCount + 1 ))
            if [[ "$retryCount" -gt 1 ]]; then
                sleep 60
            fi
        done
        if [[ "$retryCount" -ge 30 ]]; then
            exit 1
        fi
    )
}

urlencode() {
    # urlencode <string>
    old_lc_collate="$LC_COLLATE"
    LC_COLLATE=C
    
    local length="${#1}"
    for (( i = 0; i < length; i++ )); do
        local c="${1:i:1}"
        case "$c" in
            [a-zA-Z0-9.~_-])
                printf "%s" "$c"
                ;;
            *)
                printf '%%%02X' "'$c"
                ;;
        esac
    done
    
    LC_COLLATE="$old_lc_collate"
}

urldecode() {
    # urldecode <string>

    local url_encoded="${1//+/ }"
    printf '%b' "${url_encoded//%/\\x}"
}

trap 'error-notify "An error was reported on ${BASH_SOURCE[0]} line ${LINENO}."' ERR
