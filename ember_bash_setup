#!/usr/bin/env bash

export emberSharedVersion='1.1.4.13'

# Allow problems to be caught within pipelines
set -o pipefail
if [[ -z "$PS1" ]]; then
    # Make ERR trap inherited, but only if the shell is non-interactive
    set -o errtrace
fi
#set -o nounset

# More verbose debugging
PS4='+($?) $BASH_SOURCE:$FUNCNAME:$LINENO:'
export PS4

# These may not be available on non-Wreathe systems
# shellcheck disable=SC1091
source crystallize-bash_setup &> /dev/null
# shellcheck disable=SC1091
source wreathe_bash_setup &> /dev/null
# shellcheck disable=SC1091
source bash_math_functions &> /dev/null
# shellcheck disable=SC1091
source egup-env &> /dev/null

die() {
    # shellcheck disable=SC1091
    source error-notify "$@"
    exit 1
}

embasename() {
    (
        path="$1"
        if [[ "$path" == "/" ]]; then
            printf "/"
            exit 0
        elif [[ "$1" =~ '/'$ ]]; then
            path="${path::${#path}-1}"
        fi
        printf "%s" "${path##*/}"
    )
}

emreadlink() {
    (
        cd "$(dirname "$1")" || exit 1
        setVariableToCommandOutput "basename" "embasename" "$1"
        printf "%s/%s" "$PWD" "${basename:?}"
    )
}

setVariableToCommandOutput() {
    if [[ "$1" == "emSetVariableToCommandOutputVar" ]]; then
        exit 1
    fi
    emSetVariableToCommandOutputVar="$1"
    shift
    save_traps="$(trap)"
    trap - ERR
    IFS= read -rd '' "$emSetVariableToCommandOutputVar" < <( "$@" )
    trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO}."' ERR
    eval "$save_traps"
}

print() {
    printf "%s" "$1"
}

eescape() {
    (
        export eescapeString="$1"
        # shellcheck disable=SC2016
        setVariableToCommandOutput temp bash -c 'perl -0777 -e '\''print(quotemeta($ENV{eescapeString}))'\'' | sed '\''s/\\$//'\'' | sed '\''s/\\\r/\r/'\'
        temp="${temp//$'\n'/'\n'}"
        printf "%s" "${temp//$'\r'/'\r'}"
    )
}

ereplace() {
    (
        # Perl returns 0 even if it can't find the file (without extra perl code), so test first.
        if [[ ! -e "$3" ]]; then
            die "The target file does not exist."
        fi
        setVariableToCommandOutput ereplaceFrom eescape "$1"
        export ereplaceFrom
        ereplaceTo="$2"
        export ereplaceTo
        perl -0777 -p -i -e 's/$ENV{ereplaceFrom}/$ENV{ereplaceTo}/g' "$3"
    )
}

readconf() {
    local key="$1"
    local file="$2"
    if [[ -z "$file" ]]; then
        file="$1"
        key=""
    fi
    readconfValue=()
    while IFS= read -r line; do
        if ! [[ "$line" =~ ^# ]]; then
            if [[ -z "$key" ]]; then
                readconfValue+=("$line")
            else
                if [[ "$(cut -f1 -d, <<< "$line")" == "$1" ]]; then
                    readconfValue+=("$(cut -f2- -d, <<< "$line")")
                fi
            fi
        fi
    done < "$2"
}

preadconf() {
    readconf "$@"
    print "${readconfValue[0]}"
}

ia() {
    if [[ "$1" == "upload" ]]; then
        (
            # Retry wrapper for ia to work around https://github.com/jjjake/internetarchive/issues/183
            # Should strip delete option from ia arguments and implement it outside of the retry loop to prevent a hypothetical case (I think I might have just seen this) where ia deletes when it fails
            # TODO: Strip --delete option from the argument list passed to the real ia, and handle it here, to deal with the case where the file gets uploaded and deleted, and ia then crashes and exits with nonzero status despite having deleted the file, meaning it gets repeatedly called to upload a nonexistent file
            retryCount=0
            succeeded="false"
            while [[ "$succeeded" != "true" && retryCount -lt 30 ]]; do
                # Use which to prevent calling this function again.
                "$(which ia)" "$@" && succeeded="true"
                retryCount=$(( retryCount + 1 ))
                if [[ "$retryCount" -gt 1 ]]; then
                    sleep 60
                fi
            done
            if [[ "$retryCount" -ge 30 ]]; then
                exit 1
            fi
        )
    else
        ia "$@"
    fi
}

urlencode() {
    local LANG=C
    for ((i=0; i < ${#1}; i++)); do
        if [[ ${1:$i:1} =~ ^[a-zA-Z0-9\.\~_-]$ ]]; then
            printf "${1:$i:1}"
        else
            printf '%%%02X' "'${1:$i:1}"
        fi
    done
}

urldecode() {
    local url_encoded="${1//+/ }"
    printf '%b' "${url_encoded//%/\\x}"
}

trap 'error-notify "An error was reported on ${BASH_SOURCE[0]} line ${LINENO}."' ERR
