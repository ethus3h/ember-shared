#!/usr/bin/env bash

#set -x

export emberSharedVersion='1.1.4.208'

# The update script shown here requires there to be only one ebuild of ember-shared in the wreathe-overlay overlay.
# ( sudo true; newVersion="1.1.4.208"; cd "/Ember Library/Ember satellite projects/ember-shared"; eogup-single; git tag -a "v$newVersion" -m "version"; egup-single .; cd "/Ember Library/Ember satellite projects/wreathe-overlay"; eogup-single; mv app-misc/ember-shared/ember-shared-*.ebuild "app-misc/ember-shared/ember-shared-$newVersion.ebuild"; repoman manifest; egup-single; sudo layman -s wreathe-overlay; sudo emerge ember-shared )

# To use the --version option of ember_bash_setup, it is necessary to have e8787d06e61943a6874e94985b53bc0a="2dee41bf-53fb-4f65-997f-33bf50bfbb4d" and run ember_bash_setup --version. It may be important to run unset e8787d06e61943a6874e94985b53bc0a afterwards.
d1875509777f46809ff940e0aad970f0=""
if [[ "$-" == *u* ]]; then
    d1875509777f46809ff940e0aad970f0="true"
    set +u
fi
# shellcheck disable=SC2154
a9c9efb644e24ef5b9cb1ec95e279c02="$e8787d06e61943a6874e94985b53bc0a"

if [[ "$1" == "--version" ]] && [[ "$a9c9efb644e24ef5b9cb1ec95e279c02" != "2dee41bf-53fb-4f65-997f-33bf50bfbb4d" ]]; then
    esVersionA="$(sed '5q;d' "$(which ember_bash_setup)")"
    esVersionB="${esVersionA%\'*}"
    echo "${esVersionB##*\'}"
    exit 0
fi
if [[ "$d1875509777f46809ff940e0aad970f0" == "true" ]]; then
    set -u
fi
unset d1875509777f46809ff940e0aad970f0 a9c9efb644e24ef5b9cb1ec95e279c02

# Allow problems to be caught within pipelines
set -o pipefail
if [[ -z "$PS1" ]]; then
    # The shell is not interactive
    # Make traps inherited, but only if the shell is non-interactive
    set -o errtrace
    set -o functrace
    # Fail if glob doesn't match. Breaks bash completions for emerge, so non-interactive only.
    shopt -s failglob
else
    # The shell is interactive
    nano() {
        nanoLocation="$(which nano)"
        nanoFileToEdit="${!#}"
        if [[ -w "$nanoFileToEdit" ]]; then
            "$nanoLocation" -wLN "$@"
        else
            sudo -k "$nanoLocation" -wLN "$@"
        fi
    }
fi

#set -o nounset

# More verbose debugging
PS4='+($?) $BASH_SOURCE:$FUNCNAME:$LINENO:'
export PS4

# These may not be available on non-Wreathe systems
# shellcheck disable=SC1091
source crystallize-bash_setup &> /dev/null
# shellcheck disable=SC1091
source wreathe_bash_setup &> /dev/null
# shellcheck disable=SC1091
source bash_math_functions &> /dev/null
# shellcheck disable=SC1091
source egup-env &> /dev/null

die() {
    # shellcheck disable=SC1091
    source error-notify "$@"
    # Make error-notify and die no-ops (error-notify already should be from having sourced error-notify), and then trigger any traps that are set for ERR
    # I'm not sure why error-notify isn't inheriting the calling script's traps.
    error-notify() {
        true
    }
    die() {
        true
    }
    save_traps="$(trap)"
    trap 'eval "$save_traps"; false; exit 1' ERR
    ( exit 1 )
    exit 1
}

embasename() (
    path="$1"
    if [[ "$path" == "/" ]]; then
        printf "/"
        exit 0
    elif [[ "$1" =~ '/'$ ]]; then
        path="${path::${#path}-1}"
    fi
    printf "%s" "${path##*/}"
)

abspath() (
    setVariableToCommandOutput "enclosingDirectory" dirname -z "$1"
    if [[ "$2" == "--resolve-symlinks-in-enclosing-directory-path" ]]; then
        setVariableToCommandOutput "enclosingDirectory" readlink -fz "${enclosingDirectory:?}"
    fi
    cd "${enclosingDirectory:?}" || exit 1
    setVariableToCommandOutput "basename" embasename "$1"
    if [[ "${basename:?}" == "." ]]; then
        basename=""
    elif [[ "${basename:?}" == ".." ]]; then
        cd ..
        basename=""
    fi
    if [[ "$PWD" == "/" ]]; then
        # Avoid doubled slash
        print "$PWD${basename:?}"
    else
        print "$PWD/${basename:?}"
    fi
)

emreadlink() {
    abspath "$@" "--resolve-symlinks-in-enclosing-directory-path"
}

setVariableToCommandOutput() {
    if [[ "$1" == "emSetVariableToCommandOutputVar" ]]; then
        return 1
    fi
    emSetVariableToCommandOutputVar="$1"
    shift
    save_traps="$(trap)"
    trap - ERR
    IFS= read -rd '' "$emSetVariableToCommandOutputVar" < <( "$@" )
    trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR
    eval "$save_traps"
}

print() {
    printf "%s" "$@"
}

say() {
    printf '%s\n' "$@"
}

getDefaultEditor() {
    print "${FCEDIT:-${VISUAL:-${EDITOR:-nano}}}"
}

getDefaultEditorPath() {
    which "$(getDefaultEditor)"
}

defaultEditor() {
    "$(getDefaultEditorPath)" "$@"
}

emdate() (
    # If changing this, also change the copy in the error-notify script and possibly also the copy in the emberMacGNUUpgrade script.
    trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd)."' ERR

    local temp
    temp="$(date +%Y-%m-%d-%H-%M-%S-%N)_$(xxd -pu <<< "$(date +%z)")"
    echo "${temp//-/}"
)

date-uuid() (
    trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR

    local temp
    temp="$(emdate)-$(python -c 'import uuid; print str(uuid.uuid4())')"
    echo "${temp//-/}"
)

eescape() {
    (
        export eescapeString="$1"
        local temp
        # shellcheck disable=SC2016
        setVariableToCommandOutput temp bash -c 'perl -0777 -e '\''print(quotemeta($ENV{eescapeString}))'\'' | sed '\''s/\\$//'\'' | sed '\''s/\\\r/\r/'\'
        temp="${temp//$'\n'/'\n'}"
        printf "%s" "${temp//$'\r'/'\r'}"
    )
}

perl_ere_quote() {
    eescape "$@"
}

ereplace() {
    (
        # Perl returns 0 even if it can't find the file (without extra perl code), so test first.
        if [[ ! -e "$3" ]]; then
            die "The target file does not exist."
        fi
        setVariableToCommandOutput ereplaceFrom eescape "$1"
        export ereplaceFrom
        ereplaceTo="$2"
        export ereplaceTo
        perl -0777 -p -i -e 's/$ENV{ereplaceFrom}/$ENV{ereplaceTo}/g' "$3"
    )
}

ereplaceRegEx() {
    (
        # Perl returns 0 even if it can't find the file (without extra perl code), so test first.
        if [[ ! -e "$3" ]]; then
            die "The target file does not exist."
        fi
        ereplaceFrom="$1"
        ereplaceTo="$2"
        perl -0777 -p -i -e 's/'"$ereplaceFrom"'/'"$ereplaceTo"'/g' "$3"
    )
}

version_gt() {
    # from https://stackoverflow.com/questions/16989598/bash-comparing-version-numbers
    test "$(printf '%s\n' "$@" | sort -V | head -n 1)" != "$1"
}

readconf() {
    local key="$1"
    local file="$2"
    if [[ -z "$file" ]]; then
        file="$1"
        key=""
    fi
    readconfValue=()
    while IFS= read -r line; do
        if ! [[ "$line" =~ ^# ]]; then
            if [[ -z "$key" ]]; then
                readconfValue+=("$line")
            else
                if [[ "$(cut -f1 -d, <<< "$line")" == "$1" ]]; then
                    readconfValue+=("$(cut -f2- -d, <<< "$line")")
                fi
            fi
        fi
    done < "$2"
}

preadconf() {
    readconf "$@"
    print "${readconfValue[0]}"
}

ia() (
    trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR
    if [[ "$1" == "upload" ]]; then
        (
            # Retry wrapper for ia to work around https://github.com/jjjake/internetarchive/issues/183
            wantsDelete="false"
            optionArgumentPattern="^--"
            remoteNameTwopartArgumentPattern="^--remote-name="
            newParams=()
            fileArgs=()
            iterCount=0
            identifier=""
            remoteNameOverride=""
            remoteNameOverrideFound="false" # Is set to true when waiting for the second half of a two-part --remote-name option
            outerSucceeded="false"
            for param in "$@"; do
                if [[ "$remoteNameOverrideFound" == "true" ]]; then
                    # The previous argument was --remote-name, so this one is the remote name to use. Because ia only allows a single file when using --remote-name, this doesn't try to handle the case of multiple --remote-name options.
                    remoteNameOverride="$param"
                    remoteNameOverrideFound="false"
                elif [[ "$param" == "--delete" ]]; then
                    wantsDelete="true"
                    continue # Don't pass the --delete argument to ia, since this wrapper should handle it instead
                elif [[ "$param" == "--remote-name" ]]; then
                    remoteNameOverrideFound="true"
                elif [[ "$param" =~ $remoteNameTwopartArgumentPattern ]]; then
                    # This is a --remote-name argument that looks like --remote-name=blah. So, remove the prefix and set the remote name.
                    remoteNameOverride="${param#--remote-name=*}"
                fi
                if ! [[ "$param" =~ $optionArgumentPattern ]]; then
                    # Skip first two arguments ("upload" and identifier). iterCount variable is needed to figure out where we are in the argument list.
                    if [[ "$iterCount" == "0" ]]; then
                        iterCount=1
                    elif [[ "$iterCount" == "1" ]]; then
                        identifier="$param"
                        iterCount=2
                    else
                        if [[ "$param" != "-" ]]; then
                            fileArgs+=("$param")
                        fi
                    fi
                fi
                newParams+=("$param")
            done
            uploadRetryInner() (
                retryCount=0
                succeeded="false"
                while [[ "$succeeded" != "true" && "$retryCount" -lt 30 ]]; do
                    retryCount=$(( retryCount + 1 ))
                    if [[ "$retryCount" -gt 1 ]]; then
                        warn "Something went wrong: retrying upload."
                        sleep 60
                    fi

                    # Use command to prevent calling this function again.
                    command ia "${newParams[@]}" && succeeded="true"
                done
                if [[ "$retryCount" -ge 30 ]]; then
                    exit 1
                fi

                retryCount=0
                succeeded="false"
                while [[ "$succeeded" != "true" && "$retryCount" -lt 5 ]]; do
                    retryCount=$(( retryCount + 1 ))
                    if [[ "$retryCount" -gt 1 ]]; then
                        warn "Something went wrong: retrying upload integrity check."
                        sleep 60
                    fi

                    # Iterate through the uploaded files and check their checksums
                    echo "Please wait: confirming upload integrity..."
                    for file in "${fileArgs[@]}"; do
                        local knownChecksum
                        knownChecksum="$(sha1sum "$file" | awk '{print $1;}')"
                        fileToQuery=""
                        if [[ -z "$remoteNameOverride" ]]; then
                            fileToQuery="$(basename "$file")"
                        else
                            fileToQuery="$remoteNameOverride"
                        fi
                        retryUntilSuccess 5000 60 5 5 iasha1 "$identifier/$fileToQuery" > /dev/null || die "Could not get checksum for uploaded file $identifier/$fileToQuery."
                        checksumLine="$(iasha1 "$identifier/$fileToQuery")"
                        if [[ "$checksumLine" != "$knownChecksum" ]]; then
                            die "ERROR! Checksum known by Internet Archive $checksumLine does not match saved checksum known locally $knownChecksum."
                        fi
                        knownChecksumNew="$(sha1sum "$file" | awk '{print $1;}')"
                        if [[ "$checksumLine" != "$knownChecksumNew" ]]; then
                            die "ERROR! Checksum known by the Internet Archive $checksumLine does not match new checksum known locally $knownChecksumNew."
                        fi
                    done && succeeded="true"
                done
                if [[ "$retryCount" -ge 5 ]]; then
                    exit 1
                fi
                [[ "$succeeded" == "true" ]] || die "Error uploading in inner function!"
            )
            retryUntilSuccess 100 30 5 5 uploadRetryInner "$@" && outerSucceeded="true"
            [[ "$outerSucceeded" == "true" ]] || die "Error uploading!"
            if [[ "$outerSucceeded" == "true" ]] && [[ "$wantsDelete" == "true" ]]; then
                for file in "${fileArgs[@]}"; do
                    rm "${file:?}"
                done
            fi
        )
    elif [[ "$1" == "checkeddl" ]]; then
        # Wrapper around ia download. TODO: Provide the ability to use local copies (not yet implemented)
        (
            for param in "$@"; do
                retryCount=0
                succeeded="false"
                ident=""
                ident="$(iaident "$param")"
                while [[ "$succeeded" != "true" && "$retryCount" -lt 30 ]]; do
                    retryCount=$(( retryCount + 1 ))
                    if [[ "$retryCount" -gt 1 ]]; then
                        warn "Something went wrong: retrying upload."
                        sleep 60
                    fi

                    # Use command to prevent calling this function again.
                    command ia download "$ident" -C

                    # Now, check the downloaded files
                    shopt -s dotglob
                    shopt -s globstar
                    for file in "$ident"/**; do
                        [[ "$(sha1sum "$file")" == "$(iasha1 "$file")" ]] && succeeded="true"
                    done
                done
                [[ "$succeeded" == "true" ]] || die
            done
        ) || die
    elif [[ "$1" == "downloadAsStream" ]]; then
        # Wrapper around ia download. Provides the ability to get the result as a stream. Expects a URL rather than the ia download syntax, so it can act as a drop-in replacement for wgetting a file.
        (
            trap 'rm -r ${tempDir:?}; die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR
            tempDir="$(tempDir)"
            (
                cd "$tempDir" || die
                requestUrl="$2"
                path="${requestUrl#https:\/\/archive.org\/download\/}"
                identifier="${path%%\/*}"
                fileName="${path#*\/}" # Should work with files in subdirectories
                command ia download "$identifier" "$fileName" > /dev/null || die
                [[ -f "$identifier/$fileName" ]] || die
                cat "$identifier/$fileName"
            ) || die
            rm -r "$tempDir"
        ) || die
    elif [[ "$1" == "downloadHere" ]]; then
        # Wrapper around ia download. Expects a URL rather than the ia download syntax, so it can act as a drop-in replacement for wgetting a file.
        (
            requestUrl="$2"
            fileName="${requestUrl#https:\/\/archive.org\/download\/}"
            fileName="${fileName##*\/}"
            ia downloadAsStream "$requestUrl" > "$fileName" || die
        ) || die
    else
        command ia "$@" || die
    fi
)

# These ia* functions need to run in subshells so die doesn't affect the caller.
iaident() (
    local fullPath="${1#https:\/\/archive.org\/download\/}"
    local res="${fullPath%%\/*}"
    [[ -n "$res" ]] || exit 1
    print "$res"
)

iapath() (
    local fullPath="${1#https:\/\/archive.org\/download\/}"
    local res="${fullPath#*\/}"
    [[ -n "$res" ]] || exit 1
    print "$res"
)

iafilename() (
    basename "$(iapath "$1")"
)

iasha1() (
    local field="sha1"
    result="$(ia metadata "$(iaident "$1")" | { jq -r '.files[] | select(.name=="'"$(iafilename "$1")"'").'"$field" 2>/dev/null; };)"
    # jq seems to exit 0 on at least some errors
    [[ -z "$result" ]] && exit 1
    print "$result"
)

iamd5() (
    local field="md5"
    result="$(ia metadata "$(iaident "$1")" | { jq -r '.files[] | select(.name=="'"$(iafilename "$1")"'").'"$field" 2>/dev/null; };)"
    # jq seems to exit 0 on at least some errors
    [[ -z "$result" ]] && exit 1
    print "$result"
)

iaurl() (
    print "https://archive.org/download/"
    iaident "$1"
    print "/"
    iapath "$1"
)

isIaName() (
    local regex='^https:\/\/archive.org\/download\/.+$'
    if [[ "$1" =~ $regex ]]; then
        exit 0
    fi
    exit 1
)

urlencode() {
    local LANG=C
    for ((i=0; i < ${#1}; i++)); do
        if [[ ${1:$i:1} =~ ^[a-zA-Z0-9\.\~_-]$ ]]; then
            printf '%s' "${1:$i:1}"
        else
            printf '%%%02X' "'${1:$i:1}"
        fi
    done
}

urldecode() {
    local url_encoded="${1//+/ }"
    printf '%b' "${url_encoded//%/\\x}"
}

contains() {
    local e
    for e in "${@:2}"; do [[ "$e" == "$1" ]] && return 0; done
    return 1
}

allElementsEqual() {
    local e
    for e in "${@:2}"; do [[ "$e" == "$1" ]] || return 1; done
    return 0
}

join_by() {
    # from https://stackoverflow.com/questions/1527049/join-elements-of-an-array
    local d="$1"
    shift
    echo -n "$1"
    shift
    printf "%s" "${@/#/$d}"
}

pipecheck() {
    allElementsEqual "0" "$@" || die "A failure status was reported by a call to pipecheck, with the reported exit statuses $(join_by ", " "$@")"
}

retryUntilSuccess() (
    local numberRegex='^[0-9]+$'
    local maximumRetries=-1
    if [[ "$1" =~ $numberRegex ]]; then
        maximumRetries="$1"
        shift
    fi
    local maximumDelayTime=0
    if [[ "$1" =~ $numberRegex ]]; then
        maximumDelayTime="$1"
        shift
    fi
    local delayTimeBackoffIncrement=1
    if [[ "$1" =~ $numberRegex ]]; then
        delayTimeBackoffIncrement="$1"
        shift
    fi
    local retryDelayTime=0
    if [[ "$1" =~ $numberRegex ]]; then
        # This sets the initial delay time
        retryDelayTime="$1"
        shift
    fi
    local currentRetries="$maximumRetries"
    local postExecCheckSuccess=""
    postExecCheckFailHandler() {
        if [[ -z "$postExecCheckSuccess" ]] || [[ "$postExecCheckSuccess" == "1" ]]; then
            postExecCheckSuccess="1"
        else
            postExecCheckSuccess="0"
        fi
    }
    until [[ "$currentRetries" -eq "0" ]]; do
        if "$@"; then
            postExecCheckFailHandler
            break
        fi
        if [[ "$currentRetries" != "0" ]]; then
            currentRetries=$((currentRetries-1))
        fi
        sleep "$retryDelayTime"
        if [[ "$retryDelayTime" -lt "$maximumDelayTime" ]]; then
            retryDelayTime=$((retryDelayTime + delayTimeBackoffIncrement))
        fi
    done
    [[ "$postExecCheckSuccess" != "1" ]] && die "Number of allowed retries exceeded without success."
    true # needed because the if statement executes with the exit status of the last command executed
)

findso() {
    # based on https://unix.stackexchange.com/questions/22178/which-equivalent-for-shared-libraries
    if [[ "$1" == "--plain" ]]; then
        soname="$2"
    else
        soname="lib${1}.so"
    fi
    local ldpath="$LD_LIBRARY_PATH"
    local found="false"
    if [[ -z "$ldpath" ]]; then
        ldpath="$(</etc/ld.so.conf)"
    else
        local IFS=:
    fi
    for libdir in $ldpath; do
        if [[ -f "$libdir/$soname" ]]; then
            echo "$libdir/$soname"
            found="true"
            break
        fi
    done
    if [[ "$found" == "true" ]]; then
        return 0
    fi
    /sbin/ldconfig -p | awk -v needle="$1" '$1 == needle {sub(/.* => /, ""); print}'
}

normalizeWhitespace() {
    stdbuf -o0 tr '\n' ' ' | stdbuf -o0 tr '\r' ' ' | stdbuf -o0 tr -s '[:blank:]' | awk '{$1=$1};1'
}

tempDir() {
    local directoryId
    directoryId="$(crystallize-getconf WorkDirectory)/.tempDir-$(date-uuid)/"
    mkdir -p "$directoryId"
    echo "$directoryId"
}

tempFile() {
    local fileId
    fileId="$(crystallize-getconf WorkDirectory)/.tempFile-$(date-uuid)"
    touch "$fileId"
    echo "$fileId"
}

sponge() (
    local save_traps
    save_traps="$(trap)"
    trap 'error-notify "An error was reported in the sponge wrapper with the arguments $* on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR
    TMPDIR="$(crystallize-getconf WorkDirectory)"
    export TMPDIR
    command sponge "$@"
    eval "$save_traps"
)

checkedxz() (
    checkedxzErr() {
        rm -f "$output"
        rm -f "${streamingInput:?}"
    }
    local save_traps
    save_traps="$(trap)"
    trap 'checkedxzErr; die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR
    local quiet="false"
    local requestWaitAfter="false"
    if [[ "$1" == "--quiet" ]]; then
        quiet="true"
        pv() {
            cat
        }
        shift
    elif [[ "$1" == "--request-wait-after" ]]; then
        requestWaitAfter="true"
        shift
    fi
    local input="$1"
    local useStdout=""
    if [[ -n "$input" ]]; then
        shift
        if [[ "$1" == "--stdout" ]]; then
            useStdout="true"
            shift
        fi
    else
        useStdout="true"
    fi

    local output
    output="$(tempFile)"
    local fileSize
    local execMode=""
    [[ "$quiet" != "true" ]] && echo "Packing..." >&2
    if [[ -z "$input" ]] || [[ "$input" == "-" ]]; then
        execMode="stdin"
        if [[ "$input" == "-" ]]; then
            useStdout="true"
        fi
        input="$(tempFile)"
        streamingInput="$(tempFile)"
        cat > "${input:?}"
        fileSize="$(disk-size-in-bytes "$input")"
        inputCsum="$(sha512sum "$input" | awk '{print $1;}')"
    else
        execMode="file"
        fileSize="$(disk-size-in-bytes "$input")"
        inputCsum="$(sha512sum "$input" | awk '{print $1;}')"
    fi
    checkedxzInner() (
        if [[ "$execMode" == "stdin" ]]; then
            pv -tparbIfei 0.1 -s "$fileSize" < "$input" | xz "$@" --stdout - > "$output"
        else
            xz -k "$@" --stdout "$input" | pv -tparbIfei 0.1 -s "$fileSize" > "$output"
        fi
        fileSize="$(disk-size-in-bytes "$output")"
        [[ "$quiet" != "true" ]] && echo "Checking..." >&2
        testOutputCsum="$(pv -tparbIfei 0.1 -s "$fileSize" < "$output" | unxz --stdout - | sha512sum | awk '{print $1;}')"
        [[ "$requestWaitAfter" == "true" ]] && echo "Please wait..." >&2
        assert equals "$inputCsum" "$testOutputCsum" || die
    )
    retryUntilSuccess 100 checkedxzInner "$@" || { [[ "$execMode" == "stdin" ]] && rm -f "${input:?}"; die; }
    if [[ "$useStdout" == "true" ]]; then
        cat "$output"
        rm "$output"
    else
        mv "$output" "$input.xz"
    fi
    rm -f "${input:?}"
    eval "$save_traps"
)

# Test framework
{
    assert() {
        local save_traps
        save_traps="$(trap)"
        trap 'die "Assertion failed: $(join_by ", " "$@") '"on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."'"' ERR
        local verbose=""
        if [[ "$1" == "-v" ]]; then
            verbose="true"
            shift
        elif [[ "$emberSharedAssertInheritVerbose" == "true" ]]; then
            verbose="true"
        fi
        local assertionTest="$1"
        shift

        case $assertionTest in
        directoryEquals)
            # trap is workaround for what I think is https://lists.gnu.org/archive/html/bug-bash/2016-02/msg00140.html
            trap 'die "Assertion failed: $(join_by ", " "$@") '"on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."'"' ERR
            firstDir="$1"
            secondDir="$2"
            if [[ -z "$firstDir" ]] || [[ -z "$secondDir" ]]; then
                die "Both values must be non-empty."
            fi
            if [[ "$verbose" == "true" ]]; then
                # || die is workaround for what I think is https://lists.gnu.org/archive/html/bug-bash/2016-02/msg00140.html
                diff -uraN "$firstDir" "$secondDir" || die "Assertion failed: $(join_by ", " "$@") on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."
            else
                # || die is workaround for what I think is https://lists.gnu.org/archive/html/bug-bash/2016-02/msg00140.html
                diff -uraN "$firstDir" "$secondDir" > /dev/null || die "Assertion failed: $(join_by ", " "$@") on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."
            fi
            ;;
        fileEquals)
            # trap is workaround for what I think is https://lists.gnu.org/archive/html/bug-bash/2016-02/msg00140.html
            trap 'die "Assertion failed: $(join_by ", " "$@") '"on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."'"' ERR
            firstFile="$1"
            secondFile="$2"
            if [[ -z "$firstFile" ]] || [[ -z "$secondFile" ]]; then
                die "Both values must be non-empty."
            fi
            # || die is workaround for what I think is https://lists.gnu.org/archive/html/bug-bash/2016-02/msg00140.html
            assert equals "$(sha512sum "$firstFile" | awk '{print $1;}')" "$(sha512sum "$secondFile" | awk '{print $1;}')" || die "Assertion failed: $(join_by ", " "$@") on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."
            ;;
        equals)
            # trap is workaround for what I think is https://lists.gnu.org/archive/html/bug-bash/2016-02/msg00140.html
            trap 'die "Assertion failed: $(join_by ", " "$@") '"on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."'"' ERR
            # || die is workaround for what I think is https://lists.gnu.org/archive/html/bug-bash/2016-02/msg00140.html
            [[ "${1:?}" == "${2:?}" ]] || die "Assertion failed: $(join_by ", " "$@") on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."
            ;;
        *)
            trap 'error-notify "An error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR
            die "Unknown test."
            ;;
        esac
        eval "$save_traps"
    }

    passedTests="0"
    failedTests="0"
    totalTests="0"

    verboseTests=""

    runTest() {
        # This assumes that the test is a function, an external program, or a folder containing "exec" script. To force using an external program, use ./
        local verbose="$verboseTests"
        if [[ "$1" == "-v" ]]; then
            verbose="true"
            shift
        fi
        emberSharedAssertInheritVerbose=""
        if [[ "$1" == "-vv" ]]; then
            verbose="true"
            emberSharedAssertInheritVerbose="true"
            export emberSharedAssertInheritVerbose
            shift
        fi
        totalTests=$(( totalTests + 1 ))
        local testName="$1"
        shift
        testPass() {
            echo "Test $testName passed."
            passedTests=$(( passedTests + 1 ))
        }
        testFail() {
            echo "Test $testName failed."
            failedTests=$(( failedTests + 1 ))
        }
        local digitsRegex='^[0-9]+$'
        if [[ -d "$testName" ]]; then
            pushd "$testName" > /dev/null || die
            chmod +x ./exec
            if [[ "$verbose" == "true" ]]; then
                if ./exec "$@"; then
                    testPass
                else
                    testFail
                fi
            else
                if ./exec "$@" &> /dev/null; then
                    testPass
                else
                    testFail
                fi
            fi
            popd > /dev/null || die
        elif [[ -f "$testName" ]]; then
            # The test is a file to run. If you want to test a function but its name is also used by a file, wrap it in braces (like: { foo }).
            chmod +x ./"$testName"
            if [[ "$verbose" == "true" ]]; then
                if ./"$testName" "$@"; then
                    testPass
                else
                    testFail
                fi
            else
                if ./"$testName" "$@" &> /dev/null; then
                    testPass
                else
                    testFail
                fi
            fi
        elif type -t "$testName" > /dev/null; then
            # The test is a function or command name.
            if [[ "$verbose" == "true" ]]; then
                if "$testName" "$@"; then
                    testPass
                else
                    testFail
                fi
            else
                if "$testName" "$@" &> /dev/null; then
                    testPass
                else
                    testFail
                fi
            fi
         elif [[ "$testName" =~ $digitsRegex ]]; then
            # The test is an inline function like runTest { assert blah }, so all we have to do here is check the status code
            if [[ "$testName" == "0" ]]; then
                testPass
            else
                testFail
            fi
        else
            warn "Could not find the test $testName."
            testFail
        fi
    }

    reportTests() {
        local passedWord="tests"
        if [[ "$passedTests" == 1 ]]; then
            passedWord="test"
        fi
        local failedWord="tests"
        if [[ "$failedTests" == 1 ]]; then
            failedWord="test"
        fi
        local totalWord="tests"
        if [[ "$totalTests" == 1 ]]; then
            totalWord="test"
        fi
        passedPercentage="$(printf "%.3f\\n" "$(bc -l <<< "($passedTests / $totalTests) * 100")")"
        failedPercentage="$(printf "%.3f\\n" "$(bc -l <<< "($failedTests / $totalTests) * 100")")"
        echo "$passedTests $passedWord ($passedPercentage%) passed and $failedTests $failedWord ($failedPercentage%) failed out of a total of $totalTests $totalWord."
        if [[ "$failedTests" != "0" ]]; then
            totalWord="Some tests"
            if [[ "$totalTests" == 1 ]]; then
                totalWord="A test"
            fi
            error-notify "$totalWord ($failedPercentage%: $failedTests out of $totalTests) failed!"
        fi
        [[ $(( totalTests - failedTests )) == "$passedTests" ]] || die "There's a problem in the testing framework."
    }
}

trap 'error-notify "An error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR
