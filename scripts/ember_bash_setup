#!/usr/bin/env bash

# set -x

export emberSharedVersion='1.1.4.114'

# The update script shown here requires there to be only one ebuild of ember-shared in the wreathe-overlay overlay.
# ( sudo true; newVersion="1.1.4.114"; cd "/Ember Library/Ember satellite projects/ember-shared"; eogup-single; git tag -a "v$newVersion" -m "version"; egup-single .; cd "/Ember Library/Ember satellite projects/wreathe-overlay"; eogup-single; mv app-misc/ember-shared/ember-shared-*.ebuild "app-misc/ember-shared/ember-shared-$newVersion.ebuild"; repoman manifest; egup-single; sudo layman -s wreathe-overlay; sudo emerge ember-shared )

# To use the --version option of ember_bash_setup, it is necessary to have e8787d06e61943a6874e94985b53bc0a="2dee41bf-53fb-4f65-997f-33bf50bfbb4d" and run ember_bash_setup --version. It may be important to run unset e8787d06e61943a6874e94985b53bc0a afterwards.
d1875509777f46809ff940e0aad970f0=""
if [[ "$-" == *u* ]]; then
    d1875509777f46809ff940e0aad970f0="true"
    set +u
fi
# shellcheck disable=SC2154
a9c9efb644e24ef5b9cb1ec95e279c02="$e8787d06e61943a6874e94985b53bc0a"

if [[ "$1" == "--version" ]] && [[ "$a9c9efb644e24ef5b9cb1ec95e279c02" != "2dee41bf-53fb-4f65-997f-33bf50bfbb4d" ]]; then
    esVersionA="$(sed '5q;d' "$(which ember_bash_setup)")"
    esVersionB="${esVersionA%\'*}"
    echo "${esVersionB##*\'}"
    exit 0
fi
if [[ "$d1875509777f46809ff940e0aad970f0" == "true" ]]; then
    set -u
fi
unset d1875509777f46809ff940e0aad970f0 a9c9efb644e24ef5b9cb1ec95e279c02

# Allow problems to be caught within pipelines
set -o pipefail
if [[ -z "$PS1" ]]; then
    # Make traps inherited, but only if the shell is non-interactive
    set -o errtrace
    set -o functrace
fi
#set -o nounset

# More verbose debugging
PS4='+($?) $BASH_SOURCE:$FUNCNAME:$LINENO:'
export PS4

# These may not be available on non-Wreathe systems
# shellcheck disable=SC1091
source crystallize-bash_setup &> /dev/null
# shellcheck disable=SC1091
source wreathe_bash_setup &> /dev/null
# shellcheck disable=SC1091
source bash_math_functions &> /dev/null
# shellcheck disable=SC1091
source egup-env &> /dev/null

die() {
    # shellcheck disable=SC1091
    source error-notify "$@"
    # Make error-notify and die no-ops (error-notify already should be from having sourced error-notify), and then trigger any traps that are set for ERR
    # I'm not sure why error-notify isn't inheriting the calling script's traps.
    error-notify() {
        true
    }
    die() {
        true
    }
    save_traps="$(trap)"
    trap 'eval "$save_traps"; false; exit 1' ERR
    ( exit 1 )
    exit 1
}

embasename() {
    (
        path="$1"
        if [[ "$path" == "/" ]]; then
            printf "/"
            exit 0
        elif [[ "$1" =~ '/'$ ]]; then
            path="${path::${#path}-1}"
        fi
        printf "%s" "${path##*/}"
    )
}

emreadlink() {
    (
        cd "$(dirname "$1")" || exit 1
        setVariableToCommandOutput "basename" "embasename" "$1"
        printf "%s/%s" "$PWD" "${basename:?}"
    )
}

setVariableToCommandOutput() {
    if [[ "$1" == "emSetVariableToCommandOutputVar" ]]; then
        exit 1
    fi
    emSetVariableToCommandOutputVar="$1"
    shift
    save_traps="$(trap)"
    trap - ERR
    IFS= read -rd '' "$emSetVariableToCommandOutputVar" < <( "$@" )
    trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR
    eval "$save_traps"
}

print() {
    printf "%s" "$@"
}

emdate() (
    # If changing this, also change the copy in the error-notify script.
    trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd)."' ERR

    local temp
    temp="$(date +%Y-%m-%d-%H-%M-%S-%N)_$(xxd -pu <<< "$(date +%z)")"
    echo "${temp//-/}"
)

date-uuid() (
    trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR

    local temp
    temp="$(emdate)-$(python -c 'import uuid; print str(uuid.uuid4())')"
    echo "${temp//-/}"
)

eescape() {
    (
        export eescapeString="$1"
        local temp
        # shellcheck disable=SC2016
        setVariableToCommandOutput temp bash -c 'perl -0777 -e '\''print(quotemeta($ENV{eescapeString}))'\'' | sed '\''s/\\$//'\'' | sed '\''s/\\\r/\r/'\'
        temp="${temp//$'\n'/'\n'}"
        printf "%s" "${temp//$'\r'/'\r'}"
    )
}

ereplace() {
    (
        # Perl returns 0 even if it can't find the file (without extra perl code), so test first.
        if [[ ! -e "$3" ]]; then
            die "The target file does not exist."
        fi
        setVariableToCommandOutput ereplaceFrom eescape "$1"
        export ereplaceFrom
        ereplaceTo="$2"
        export ereplaceTo
        perl -0777 -p -i -e 's/$ENV{ereplaceFrom}/$ENV{ereplaceTo}/g' "$3"
    )
}

ereplaceRegEx() {
    (
        # Perl returns 0 even if it can't find the file (without extra perl code), so test first.
        if [[ ! -e "$3" ]]; then
            die "The target file does not exist."
        fi
        ereplaceFrom="$1"
        export ereplaceFrom
        ereplaceTo="$2"
        perl -0777 -p -i -e 's/$ENV{ereplaceFrom}/'"$ereplaceTo"'/g' "$3"
    )
}

readconf() {
    local key="$1"
    local file="$2"
    if [[ -z "$file" ]]; then
        file="$1"
        key=""
    fi
    readconfValue=()
    while IFS= read -r line; do
        if ! [[ "$line" =~ ^# ]]; then
            if [[ -z "$key" ]]; then
                readconfValue+=("$line")
            else
                if [[ "$(cut -f1 -d, <<< "$line")" == "$1" ]]; then
                    readconfValue+=("$(cut -f2- -d, <<< "$line")")
                fi
            fi
        fi
    done < "$2"
}

preadconf() {
    readconf "$@"
    print "${readconfValue[0]}"
}

ia() (
    trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR
    if [[ "$1" == "upload" ]]; then
        (
            # Retry wrapper for ia to work around https://github.com/jjjake/internetarchive/issues/183
            wantsDelete="false"
            patternMatch="^--"
            newParams=()
            fileArgs=()
            iterCount=0
            for param in "$@"; do
                if [[ "$param" == "--delete" ]]; then
                    wantsDelete="true"
                    continue
                fi
                if ! [[ "$param" =~ $patternMatch ]]; then
                    # Skip first two arguments ("upload" and identifier)
                    if [[ "$iterCount" == "0" ]]; then
                        iterCount=1
                    elif [[ "$iterCount" == "1" ]]; then
                        iterCount=2
                    else
                        fileArgs+=("$param")
                    fi
                fi
                newParams+=("$param")
            done
            retryCount=0
            succeeded="false"
            while [[ "$succeeded" != "true" && "$retryCount" -lt 30 ]]; do
                # Use which to prevent calling this function again.
                "$(which ia)" "${newParams[@]}" && succeeded="true"
                retryCount=$(( retryCount + 1 ))
                if [[ "$retryCount" -gt 1 ]]; then
                    sleep 60
                fi
            done
            if [[ "$retryCount" -ge 30 ]]; then
                exit 1
            fi
            if [[ "$succeeded" == "true" ]] && [[ "$wantsDelete" == "true" ]]; then
                for file in "${fileArgs[@]}"; do
                    rm "${file:?}"
                done
            fi
        ) || die
    elif [[ "$1" == "download" ]]; then
        # Wrapper around ia download. TODO: Provide the ability to use local copies (not yet implemented)
        "$(which ia)" "$@"
    elif [[ "$1" == "downloadAsStream" ]]; then
        # Wrapper around ia download. Provides the ability to get the result as a stream. Expects a URL rather than the ia download syntax, so it can act as a drop-in replacement for wgetting a file.
        (
            trap 'rm -r ${tempDir:?}; die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR
            tempDir="$(tempDir)"
            (
                cd "$tempDir" || die
                requestUrl="$2"
                path="${requestUrl#https:\/\/archive.org\/download\/}"
                identifier="${path%%\/*}"
                fileName="${path#*\/}" # Should work with files in subdirectories
                "$(which ia)" download "$identifier" "$fileName" > /dev/null
                [[ -f "$identifier/$fileName" ]] || die
                cat "$identifier/$fileName"
            ) || die
            rm -r "$tempDir"
        ) || die
    elif [[ "$1" == "downloadHere" ]]; then
        # Wrapper around ia download. Expects a URL rather than the ia download syntax, so it can act as a drop-in replacement for wgetting a file.
        (
            requestUrl="$2"
            fileName="${requestUrl#https:\/\/archive.org\/download\/}"
            fileName="${fileName##*\/}"
            ia downloadAsStream "$requestUrl" > "$fileName"
        ) || die
    else
        "$(which ia)" "$@"
    fi
)

urlencode() {
    local LANG=C
    for ((i=0; i < ${#1}; i++)); do
        if [[ ${1:$i:1} =~ ^[a-zA-Z0-9\.\~_-]$ ]]; then
            printf '%s' "${1:$i:1}"
        else
            printf '%%%02X' "'${1:$i:1}"
        fi
    done
}

urldecode() {
    local url_encoded="${1//+/ }"
    printf '%b' "${url_encoded//%/\\x}"
}

contains() {
    local e
    for e in "${@:2}"; do [[ "$e" == "$1" ]] && return 0; done
    return 1
}

allElementsEqual() {
    local e
    for e in "${@:2}"; do [[ "$e" == "$1" ]] || return 1; done
    return 0
}

join_by() {
    # from https://stackoverflow.com/questions/1527049/join-elements-of-an-array
    local d="$1"
    shift
    echo -n "$1"
    shift
    printf "%s" "${@/#/$d}"
}

pipecheck() {
    allElementsEqual "0" "$@" || die "A failure status was reported by a call to pipecheck, with the reported exit statuses $(join_by ", " "$@")"
}

findso() {
    # based on https://unix.stackexchange.com/questions/22178/which-equivalent-for-shared-libraries
    if [[ "$1" == "--plain" ]]; then
        soname="$2"
    else
        soname="lib${1}.so"
    fi
    local ldpath="$LD_LIBRARY_PATH"
    local found="false"
    if [[ -z "$ldpath" ]]; then
        ldpath="$(</etc/ld.so.conf)"
    else
        local IFS=:
    fi
    for libdir in $ldpath; do
        if [[ -f "$libdir/$soname" ]]; then
            echo "$libdir/$soname"
            found="true"
            break
        fi
    done
    if [[ "$found" == "true" ]]; then
        return 0
    fi
    /sbin/ldconfig -p | awk -v needle="$1" '$1 == needle {sub(/.* => /, ""); print}'
}

alias normalizeWhitespace=xargs

tempDir() {
    local directoryId
    directoryId="$(crystallize-getconf WorkDirectory)/.tempDir-$(date-uuid)/"
    mkdir -p "$directoryId"
    echo "$directoryId"
}

tempFile() {
    local fileId
    fileId="$(crystallize-getconf WorkDirectory)/.tempFile-$(date-uuid)"
    touch "$fileId"
    echo "$fileId"
}

sponge() (
    TMPDIR="$(crystallize-getconf WorkDirectory)"
    export TMPDIR
    spongeLocation="$(which sponge)"
    "$spongeLocation" "$@"
)

checkedxz() (
    checkedxzErr() {
        rm -f "$output"
        rm -f "${streamingInput:?}"
    }
    trap 'checkedxzErr; die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR
    local quiet="false"
    local requestWaitAfter="false"
    if [[ "$1" == "--quiet" ]]; then
        quiet="true"
        pv() {
            cat
        }
        shift
    elif [[ "$1" == "--request-wait-after" ]]; then
        requestWaitAfter="true"
        shift
    fi
    local input="$1"
    local useStdout=""
    if [[ -n "$input" ]]; then
        shift
        if [[ "$1" == "--stdout" ]]; then
            useStdout="true"
            shift
        fi
    else
        useStdout="true"
    fi

    local output
    output="$(tempFile)"
    local fileSize
    [[ "$quiet" != "true" ]] && echo "Packing..." >&2
    if [[ -z "$input" ]] || [[ "$input" == "-" ]]; then
        if [[ "$input" == "-" ]]; then
            useStdout="true"
        fi
        input="$(tempFile)"
        streamingInput="$(tempFile)"
        sponge "${input:?}"
        fileSize="$(disk-size-in-bytes "$input")"
        inputCsum="$(sha512sum "$input" | awk '{print $1;}')"
        pv -tparbIfei 0.1 -s "$fileSize" < "$input" | xz "$@" --stdout - > "$output"
        rm "$input"
    else
        fileSize="$(disk-size-in-bytes "$input")"
        inputCsum="$(sha512sum "$input" | awk '{print $1;}')"
        xz -k "$@" --stdout "$input" | pv -tparbIfei 0.1 -s "$fileSize" > "$output"
    fi
    fileSize="$(disk-size-in-bytes "$output")"
    [[ "$quiet" != "true" ]] && echo "Checking..." >&2
    testOutputCsum="$(pv -tparbIfei 0.1 -s "$fileSize" < "$output" | unxz --stdout - | sha512sum | awk '{print $1;}')"
    [[ "$requestWaitAfter" == "true" ]] && echo "Please wait..." >&2
    assert equals "$inputCsum" "$testOutputCsum" || die
    if [[ "$useStdout" == "true" ]]; then
        cat "$output"
        rm "$output"
    else
        mv "$output" "$input.xz"
    fi
    rm -f "${input:?}"
)

# Test framework
{
    assert() {
        local save_traps
        save_traps="$(trap)"
        #trap 'die "Assertion failed: $(join_by ", " "$@") '"on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."'"' ERR
        trap 'exit 1' ERR
        local verbose=""
        if [[ "$1" == "-v" ]]; then
            verbose="true"
            shift
        fi
        local assertionTest="$1"
        shift

        case $assertionTest in
        directoryEquals)
            firstDir="$1"
            secondDir="$2"
            if [[ -z "$firstDir" ]] || [[ -z "$secondDir" ]]; then
                die "Both values must be non-empty."
            fi
            if [[ "$verbose" == "true" ]]; then
                diff -uraN "$firstFile" "$2"
            else
                diff -uraN "$firstDir" "$secondDir" > /dev/null
            fi
            ;;
        fileEquals)
            firstFile="$1"
            secondFile="$2"
            if [[ -z "$firstFile" ]] || [[ -z "$secondFile" ]]; then
                die "Both values must be non-empty."
            fi
            assert equals "$(sha512sum "$firstFile" | awk '{print $1;}')" "$(sha512sum "$secondFile" | awk '{print $1;}')"
            trap
            false
            echo $?
            die
            ;;
        equals)
            [[ "${1:?}" == "${2:?}" ]]
            ;;
        *)
            die "Unknown test."
            ;;
        esac
        eval "$save_traps"
    }

    passedTests="0"
    failedTests="0"
    totalTests="0"

    verboseTests=""

    runTest() {
        # This assumes that the test is a function, an external program, or a folder containing "exec" script. To force using an external program, use ./
        local verbose="$verboseTests"
        if [[ "$1" == "-v" ]]; then
            verbose="true"
            shift
        fi
        totalTests=$(( totalTests + 1 ))
        local testName="$1"
        shift
        testPass() {
            echo "Test $testName passed."
            passedTests=$(( passedTests + 1 ))
        }
        testFail() {
            echo "Test $testName failed."
            failedTests=$(( failedTests + 1 ))
        }
        local digitsRegex='^[0-9]+$'
        if [[ -d "$testName" ]]; then
            pushd "$testName" > /dev/null || die
            chmod +x ./exec
            if [[ "$verbose" == "true" ]]; then
                if ./exec "$@"; then
                    testPass
                else
                    testFail
                fi
            else
                if ./exec "$@" &> /dev/null; then
                    testPass
                else
                    testFail
                fi
            fi
            popd > /dev/null || die
        elif [[ -f "$testName" ]]; then
            # The test is a file to run. If you want to test a function but its name is also used by a file, wrap it in braces (like: { foo }).
            chmod +x ./"$testName"
            if [[ "$verbose" == "true" ]]; then
                if ./"$testName" "$@"; then
                    testPass
                else
                    testFail
                fi
            else
                if ./"$testName" "$@" &> /dev/null; then
                    testPass
                else
                    testFail
                fi
            fi
        elif type -t "$testName" > /dev/null; then
            # The test is a function or command name.
            if [[ "$verbose" == "true" ]]; then
                if "$testName" "$@"; then
                    testPass
                else
                    testFail
                fi
            else
                if "$testName" "$@" &> /dev/null; then
                    testPass
                else
                    testFail
                fi
            fi
         elif [[ "$testName" =~ $digitsRegex ]]; then
            # The test is an inline function like runTest { assert blah }, so all we have to do here is check the status code
            if [[ "$testName" == "0" ]]; then
                testPass
            else
                testFail
            fi
        else
            warn "Could not find the test $testName."
            testFail
        fi
    }

    reportTests() {
        local passedWord="tests"
        if [[ "$passedTests" == 1 ]]; then
            passedWord="test"
        fi
        local failedWord="tests"
        if [[ "$failedTests" == 1 ]]; then
            failedWord="test"
        fi
        local totalWord="tests"
        if [[ "$totalTests" == 1 ]]; then
            totalWord="test"
        fi
        passedPercentage="$(printf "%.3f\\n" "$(bc -l <<< "($passedTests / $totalTests) * 100")")"
        failedPercentage="$(printf "%.3f\\n" "$(bc -l <<< "($failedTests / $totalTests) * 100")")"
        echo "$passedTests $passedWord ($passedPercentage%) passed and $failedTests $failedWord ($failedPercentage%) failed out of a total of $totalTests $totalWord."
        if [[ "$failedTests" != "0" ]]; then
            totalWord="Some tests"
            if [[ "$totalTests" == 1 ]]; then
                totalWord="A test"
            fi
            error-notify "$totalWord ($failedPercentage%: $failedTests out of $totalTests) failed!"
        fi
        [[ $(( totalTests - failedTests )) == "$passedTests" ]] || die "There's a problem in the testing framework."
    }
}

trap 'error-notify "An error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR
