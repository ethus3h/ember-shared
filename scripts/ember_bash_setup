#!/usr/bin/env bash

#set -x

export emberSharedVersion='1.1.4.278'

# The update script shown here requires there to be only one ebuild of ember-shared in the wreathe-overlay overlay.
# ( sudo true; newVersion="1.1.4.278"; cd "/Ember Library/Ember satellite projects/ember-shared"; eogup-single; git tag -a "v$newVersion" -m "version"; egup-single .; cd "/Ember Library/Ember satellite projects/wreathe-overlay"; eogup-single; mv app-misc/ember-shared/ember-shared-*.ebuild "app-misc/ember-shared/ember-shared-$newVersion.ebuild"; repoman manifest; egup-single; sudo layman -s wreathe-overlay; sudo emerge ember-shared; sudo dispatch-conf )

# To use the --version option of ember_bash_setup, it is necessary to have e8787d06e61943a6874e94985b53bc0a="2dee41bf-53fb-4f65-997f-33bf50bfbb4d" and run ember_bash_setup --version. It may be important to run unset e8787d06e61943a6874e94985b53bc0a afterwards.
d1875509777f46809ff940e0aad970f0=""
if [[ "$-" == *u* ]]; then
    d1875509777f46809ff940e0aad970f0="true"
    set +u
fi
# shellcheck disable=SC2154
a9c9efb644e24ef5b9cb1ec95e279c02="$e8787d06e61943a6874e94985b53bc0a"

if [[ "$1" == "--version" ]] && [[ "$a9c9efb644e24ef5b9cb1ec95e279c02" != "2dee41bf-53fb-4f65-997f-33bf50bfbb4d" ]]; then
    esVersionA="$(sed '5q;d' "$(type -P ember_bash_setup)")"
    esVersionB="${esVersionA%\'*}"
    echo "${esVersionB##*\'}"
    exit 0
fi
if [[ "$d1875509777f46809ff940e0aad970f0" == "true" ]]; then
    set -u
fi
unset d1875509777f46809ff940e0aad970f0 a9c9efb644e24ef5b9cb1ec95e279c02

# Allow problems to be caught within pipelines
set -o pipefail
if [[ -z "$PS1" ]]; then
    # The shell is not interactive
    # Make traps inherited, but only if the shell is non-interactive
    set -o errtrace
    set -o functrace
    # Fail if glob doesn't match. Breaks bash completions for emerge, so non-interactive only.
    shopt -s failglob
else
    # The shell is interactive
    nano() {
        nanoLocation="$(type -P nano)"
        nanoFileToEdit="${!#}"
        if [[ -w "$nanoFileToEdit" ]]; then
            "$nanoLocation" -wLN "$@"
        else
            sudo -k "$nanoLocation" -wLN "$@"
        fi
    }
fi

#set -o nounset

# More verbose debugging
PS4='+($?) $BASH_SOURCE:$FUNCNAME:$LINENO:'
export PS4

# These may not be available on non-Wreathe systems
# shellcheck disable=SC1091
source crystallize-bash_setup &> /dev/null || true
# shellcheck disable=SC1091
source wreathe_bash_setup &> /dev/null || true
# shellcheck disable=SC1091
source bash_math_functions &> /dev/null || true
# shellcheck disable=SC1091
source egup-env &> /dev/null || true

die() {
    # shellcheck disable=SC1091
    source error-notify "$@"
    # Make error-notify and die no-ops (error-notify already should be from having sourced error-notify), and then trigger any traps that are set for ERR
    # I'm not sure why error-notify isn't inheriting the calling script's traps.
    error-notify() {
        true
    }
    die() {
        true
    }
    save_traps="$(trap)"
    trap 'eval "$save_traps"; false; exit 1' ERR
    ( exit 1 )
    exit 1
}

embasename() (
    path="$1"
    if [[ "$path" == "/" ]]; then
        printf "/"
        exit 0
    elif [[ "$1" =~ '/'$ ]]; then
        path="${path::${#path}-1}"
    fi
    printf "%s" "${path##*/}"
)

abspath() (
    setVariableToCommandOutput "enclosingDirectory" dirname -z "$1"
    if [[ "$2" == "--resolve-symlinks-in-enclosing-directory-path" ]]; then
        setVariableToCommandOutput "enclosingDirectory" readlink -fz "${enclosingDirectory:?}"
    fi
    cd "${enclosingDirectory:?}" || exit 1
    setVariableToCommandOutput "basename" embasename "$1"
    if [[ "${basename:?}" == "." ]]; then
        basename=""
    elif [[ "${basename:?}" == ".." ]]; then
        cd ..
        basename=""
    fi
    if [[ "$PWD" == "/" ]]; then
        # Avoid doubled slash
        print "$PWD${basename:?}"
    else
        print "$PWD/${basename:?}"
    fi
)

emreadlink() {
    abspath "$@" "--resolve-symlinks-in-enclosing-directory-path"
}

setVariableToCommandOutput() {
    if [[ "$1" == "emSetVariableToCommandOutputVar" ]]; then
        return 1
    fi
    emSetVariableToCommandOutputVar="$1"
    shift
    save_traps="$(trap)"
    trap - ERR
    IFS= read -rd '' "$emSetVariableToCommandOutputVar" < <( "$@" )
    trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR
    eval "$save_traps"
}

print() {
    printf "%s" "$@"
}

say() {
    printf '%s\n' "$@"
}

tr() {
    if [[ "$OSTYPE" = darwin* ]]; then
        LC_CTYPE=C command tr "$@"
    else
        command tr "$@"
    fi
}

getDefaultEditor() {
    print "${FCEDIT:-${VISUAL:-${EDITOR:-nano}}}"
}

getDefaultEditorPath() {
    type -P "$(getDefaultEditor)"
}

defaultEditor() {
    "$(getDefaultEditorPath)" "$@"
}

emdate() (
    # If changing this, also change the copy in the error-notify script and possibly also the copy in the emberMacGNUUpgrade script.
    trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd)."' ERR

    local temp
    temp="$(date +%Y-%m-%d-%H-%M-%S-%N)_$(xxd -pu <<< "$(date +%z)")"
    echo "${temp//-/}"
)

date-uuid() (
    trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR

    local temp
    temp="$(emdate)-$(python -c 'import uuid; print str(uuid.uuid4())')"
    echo "${temp//-/}"
)

eescape() {
    (
        export eescapeString="$1"
        local temp
        # shellcheck disable=SC2016
        setVariableToCommandOutput temp bash -c 'perl -0777 -e '\''print(quotemeta($ENV{eescapeString}))'\'' | sed '\''s/\\$//'\'' | sed '\''s/\\\r/\r/'\'
        temp="${temp//$'\n'/'\n'}"
        printf "%s" "${temp//$'\r'/'\r'}"
    )
}

perl_ere_quote() {
    eescape "$@"
}

prefixPipe() {
    cat <(print "$1") <(cat -)
}

suffixPipe() {
    cat <(cat -) <(print "$1")
}

surroundPipe() {
    cat <(print "$1") <(cat -) <(print "$2")
}

removeDuplicateLines() {
    awk '!seen[$0]++' "$@"
}

isEmptyDir() (
    if [[ -d "$1" ]]; then
        # shellcheck disable=SC2063
        if find "$1" -maxdepth 0 -type d -empty | grep -E '.*' 2>/dev/null; then
            exit 0
        fi
        exit 1
    fi
    exit 1
)

print_r() {
    local arr=("$@")
    declare -p arr
}

spushd() { # don't print directory by default
    pushd "$@" > /dev/null || false
}

spopd() { # don't print directory by default
    popd "$@" > /dev/null || false
}

ereplace() {
    (
        # Perl returns 0 even if it can't find the file (without extra perl code), so test first.
        if [[ ! -e "$3" ]]; then
            die "ereplace: The target file $3 does not exist."
        fi
        setVariableToCommandOutput ereplaceFrom eescape "$1"
        export ereplaceFrom
        ereplaceTo="$2"
        export ereplaceTo
        perl -0777 -p -i -e 's/$ENV{ereplaceFrom}/$ENV{ereplaceTo}/g' "$3"
    )
}

ereplaceRegEx() {
    (
        # Perl returns 0 even if it can't find the file (without extra perl code), so test first.
        if [[ ! -e "$3" ]]; then
            die "ereplaceRegEx: The target file $3 does not exist."
        fi
        ereplaceFrom="$1"
        ereplaceTo="$2"
        perl -0777 -p -i -e 's/'"$ereplaceFrom"'/'"$ereplaceTo"'/g' "$3"
    )
}

version_gt() {
    # from https://stackoverflow.com/questions/16989598/bash-comparing-version-numbers
    test "$(printf '%s\n' "$@" | sort -V | head -n 1)" != "$1"
}

isNonnegativeInteger() {
    # Can just use [[ "$var" == +([0-9]) ]], but the version of bash provided by Homebrew on macOS doesn't handle this correctly, so it's reimplemented here.
    local re='^[0-9]+$'
    if [[ "$1" =~ $re ]]; then
        return 0
    else
        return 1
    fi
}

readconf() {
    local key="$1"
    local file="$2"
    if [[ -z "$file" ]]; then
        file="$1"
        key=""
    fi
    readconfValue=()
    while IFS= read -r line; do
        if ! [[ "$line" =~ ^# ]]; then
            if [[ -z "$key" ]]; then
                readconfValue+=("$line")
            else
                if [[ "$(cut -f1 -d, <<< "$line")" == "$1" ]]; then
                    readconfValue+=("$(cut -f2- -d, <<< "$line")")
                fi
            fi
        fi
    done < "$2"
}

preadconf() {
    readconf "$@"
    print "${readconfValue[0]}"
}

ia() (
    trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR
    if [[ "$1" == "upload" ]]; then
        (
            # Retry wrapper for ia to work around https://github.com/jjjake/internetarchive/issues/183
            wantsDelete="false"
            optionArgumentPattern="^--"
            remoteNameTwopartArgumentPattern="^--remote-name="
            newParams=()
            fileArgs=()
            iterCount=0
            identifier=""
            remoteNameOverride=""
            remoteNameOverrideFound="false" # Is set to true when waiting for the second half of a two-part --remote-name option
            outerSucceeded="false"
            for param in "$@"; do
                if [[ "$remoteNameOverrideFound" == "true" ]]; then
                    # The previous argument was --remote-name, so this one is the remote name to use. Because ia only allows a single file when using --remote-name, this doesn't try to handle the case of multiple --remote-name options.
                    remoteNameOverride="$param"
                    remoteNameOverrideFound="false"
                elif [[ "$param" == "--delete" ]]; then
                    wantsDelete="true"
                    continue # Don't pass the --delete argument to ia, since this wrapper should handle it instead
                elif [[ "$param" == "--remote-name" ]]; then
                    remoteNameOverrideFound="true"
                elif [[ "$param" =~ $remoteNameTwopartArgumentPattern ]]; then
                    # This is a --remote-name argument that looks like --remote-name=blah. So, remove the prefix and set the remote name.
                    remoteNameOverride="${param#--remote-name=*}"
                fi
                if ! [[ "$param" =~ $optionArgumentPattern ]]; then
                    # Skip first two arguments ("upload" and identifier). iterCount variable is needed to figure out where we are in the argument list.
                    if [[ "$iterCount" == "0" ]]; then
                        iterCount=1
                    elif [[ "$iterCount" == "1" ]]; then
                        identifier="$param"
                        iterCount=2
                    else
                        if [[ "$param" != "-" ]]; then
                            fileArgs+=("$param")
                        fi
                    fi
                fi
                newParams+=("$param")
            done
            uploadRetryInner() (
                retryCount=0
                succeeded="false"
                while [[ "$succeeded" != "true" && "$retryCount" -lt 30 ]]; do
                    retryCount=$(( retryCount + 1 ))
                    if [[ "$retryCount" -gt 1 ]]; then
                        warn "Something went wrong: retrying upload."
                        sleep 60
                    fi

                    # Use command to prevent calling this function again.
                    command ia "${newParams[@]}" && succeeded="true"
                done
                if [[ "$retryCount" -ge 30 ]]; then
                    exit 1
                fi

                retryCount=0
                succeeded="false"
                while [[ "$succeeded" != "true" && "$retryCount" -lt 5 ]]; do
                    retryCount=$(( retryCount + 1 ))
                    if [[ "$retryCount" -gt 1 ]]; then
                        warn "Something went wrong: retrying upload integrity check."
                        sleep 60
                    fi

                    # Iterate through the uploaded files and check their checksums
                    echo "Please wait: confirming upload integrity..."
                    for file in "${fileArgs[@]}"; do
                        local knownChecksum
                        knownChecksum="$(sha1sum "$file" | awk '{print $1;}')"
                        fileToQuery=""
                        if [[ -z "$remoteNameOverride" ]]; then
                            fileToQuery="$(basename "$file")"
                        else
                            fileToQuery="$remoteNameOverride"
                        fi
                        retryUntilSuccess 5000 60 5 5 iasha1 "$identifier/$fileToQuery" > /dev/null || die "Could not get checksum for uploaded file $identifier/$fileToQuery."
                        checksumLine="$(iasha1 "$identifier/$fileToQuery")"
                        if [[ "$checksumLine" != "$knownChecksum" ]]; then
                            die "ERROR! Checksum known by Internet Archive $checksumLine does not match saved checksum known locally $knownChecksum."
                        fi
                        knownChecksumNew="$(sha1sum "$file" | awk '{print $1;}')"
                        if [[ "$checksumLine" != "$knownChecksumNew" ]]; then
                            die "ERROR! Checksum known by the Internet Archive $checksumLine does not match new checksum known locally $knownChecksumNew."
                        fi
                    done && succeeded="true"
                done
                if [[ "$retryCount" -ge 5 ]]; then
                    exit 1
                fi
                [[ "$succeeded" == "true" ]] || die "Error uploading in inner function!"
            )
            retryUntilSuccess 100 30 5 5 uploadRetryInner "$@" && outerSucceeded="true"
            [[ "$outerSucceeded" == "true" ]] || die "Error uploading!"
            if [[ "$outerSucceeded" == "true" ]] && [[ "$wantsDelete" == "true" ]]; then
                for file in "${fileArgs[@]}"; do
                    rm "${file:?}"
                done
            fi
        )
    elif [[ "$1" == "checkeddl" ]]; then
        # Wrapper around ia download. TODO: Provide the ability to use local copies (not yet implemented)
        (
            for param in "${@:2}"; do
                retryCount=0
                succeeded=""
                ident=""
                ident="$(iaident "$param")"
                while [[ "$succeeded" != "true" && "$retryCount" -lt 30 ]]; do
                    succeeded=""
                    retryCount=$(( retryCount + 1 ))
                    if [[ "$retryCount" -gt 1 ]]; then
                        warn "Something went wrong: retrying download."
                        sleep 60
                    fi

                    # Use command to prevent calling this function again.
                    command ia download "$ident" -C

                    # Now, check the downloaded files
                    shopt -s dotglob
                    shopt -s globstar
                    # TODO: See if IA items can hold files with newlines in their names, and figure out if this breaks on that. Also, it would be nice to be able to get rid of the "ia list" (e.g. by doing it locally from the files XML) to avoid needing network access.
                    while read -r fileNameToCheck; do
                        file="$ident/$fileNameToCheck"
                        if [[ -f "$file" ]] && [[ "$(sha1sum "$file" | awk '{print $1;}')" == "$(iasha1 "$file")" ]] && ( [[ "$succeeded" == "true" ]] || [[ -z "$succeeded" ]] ); then
                                succeeded="true"
                        else
                            succeeded="false"
                            continue
                        fi
                    done < <(ia list "$ident")
                done
                [[ "$succeeded" == "true" ]] || die
            done
        ) || die
    elif [[ "$1" == "downloadAsStream" ]]; then
        # Wrapper around ia download. Provides the ability to get the result as a stream. Expects a URL rather than the ia download syntax, so it can act as a drop-in replacement for wgetting a file.
        (
            trap 'rm -r ${tempDir:?}; die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR
            tempDir="$(bigTempDir)"
            (
                cd "$tempDir" || die
                requestUrl="$2"
                path="${requestUrl#https:\/\/archive.org\/download\/}"
                identifier="${path%%\/*}"
                fileName="${path#*\/}" # Should work with files in subdirectories
                command ia download "$identifier" "$fileName" > /dev/null || die
                [[ -f "$identifier/$fileName" ]] || die
                cat "$identifier/$fileName"
            ) || die
            rm -r "$tempDir"
        ) || die
    elif [[ "$1" == "downloadHere" ]]; then
        # Wrapper around ia download. Expects a URL rather than the ia download syntax, so it can act as a drop-in replacement for wgetting a file.
        (
            requestUrl="$2"
            fileName="${requestUrl#https:\/\/archive.org\/download\/}"
            fileName="${fileName##*\/}"
            ia downloadAsStream "$requestUrl" > "$fileName" || die
        ) || die
    else
        command ia "$@" || die
    fi
)

# These ia* functions need to run in subshells so die doesn't affect the caller.
iaident() (
    local fullPath="${1#https:\/\/archive.org\/download\/}"
    local res="${fullPath%%\/*}"
    [[ -n "$res" ]] || exit 1
    print "$res"
)

iapath() (
    local fullPath="${1#https:\/\/archive.org\/download\/}"
    local res="${fullPath#*\/}"
    [[ -n "$res" ]] || exit 1
    print "$res"
)

iafilename() (
    basename "$(iapath "$1")"
)

iasha1() (
    local field="sha1"
    local result
    if [[ "$(iapath "$1")" == "$(iaident "$1")"_files.xml ]]; then
        # TODO: Decide whether this is the right way to go about this. Right now, because item files XMLs do not have checksums available for them from the Internet Archive (since the XML files are where the checksums are kept), iasha1 will retrieve it and calculate the checksum dynamically. This could be suboptimal (or even harmful) since there is no guarantee that the returned value is correct; this behavior may change in later versions. Also, check whether it works with on-the-fly derivative files, which may break when checked using this, e.g. when using crystallize-backup, because of the same issue of not having checksums listed in the XML (I don't know if they are).
        result="$(wget -qO - "https://archive.org/download/$(iaident "$1")/$(iaident "$1")"_files.xml | sha1sum | awk '{print $1;}')"
    else
        result="$(ia metadata "$(iaident "$1")" | { jq -r '.files[] | select(.name=="'"$(iapath "$1")"'").'"$field" 2>/dev/null; };)"
    fi
    # jq seems to exit 0 on at least some errors
    [[ -z "$result" ]] && exit 1
    print "$result"
)

iamd5() (
    local field="md5"
    local result
    if [[ "$(iapath "$1")" == "$(iaident "$1")"_files.xml ]]; then
        # TODO: Decide whether this is the right way to go about this. Right now, because item files XMLs do not have checksums available for them from the Internet Archive (since the XML files are where the checksums are kept), iamd5 will retrieve it and calculate the checksum dynamically. This could be suboptimal (or even harmful) since there is no guarantee that the returned value is correct; this behavior may change in later versions. Also, check whether it works with on-the-fly derivative files, which may break when checked using this, e.g. when using crystallize-backup, because of the same issue of not having checksums listed in the XML (I don't know if they are).
        result="$(wget -O - "https://archive.org/download/$(iaident "$1")/$(iaident "$1")"_files.xml | md5sum | awk '{print $1;}')"
    else
        result="$(ia metadata "$(iaident "$1")" | { jq -r '.files[] | select(.name=="'"$(iapath "$1")"'").'"$field" 2>/dev/null; };)"
    fi
    # jq seems to exit 0 on at least some errors
    [[ -z "$result" ]] && exit 1
    print "$result"
)

iaurl() (
    print "https://archive.org/download/"
    iaident "$1"
    print "/"
    iapath "$1"
)

isIaName() (
    local regex='^https:\/\/archive.org\/download\/.+$'
    if [[ "$1" =~ $regex ]]; then
        exit 0
    fi
    exit 1
)

hasWebProtocol() (
    local httpRegex='^https?:\/\/.+$'
    local ftpRegex='^ftp:\/\/.+$'
    if [[ "$1" =~ $httpRegex ]] || [[ "$1" =~ $ftpRegex ]]; then
        exit 0
    fi
    exit 1
)

# TODO
#a() { cd /home/grabbot/grabs/ && grab-site --no-dupespotter --concurrency=5 --wpull-args=--warc-move=/home/grabbot/warcdealer/\ --read-timeout=3600\ --connect-timeout=20\ --dns-timeout=20\ --retry-connrefused\ --retry-dns-error\ --max-redirect=128\ --phantomjs-scroll=50000\ --phantomjs-exe=/phantomjs-1.9.8-linux-x86_64/bin/phantomjs\ --content-on-error\ --tries=1024 "$@"; }
#o() { cd /home/grabbot/grabs/ && grab-site --no-dupespotter --concurrency=5 --wpull-args=--warc-move=/home/grabbot/warcdealer/\ --read-timeout=3600\ --connect-timeout=20\ --dns-timeout=20\ --retry-connrefused\ --retry-dns-error\ --max-redirect=128\ --phantomjs-scroll=50000\ --phantomjs-exe=/phantomjs-1.9.8-linux-x86_64/bin/phantomjs\ --content-on-error\ --tries=1024 --1 "$@"; }
#aq() { cd /home/grabbot/grabs/ && grab-site --no-dupespotter --concurrency=5 --wpull-args=--warc-move=/home/grabbot/warcdealer/\ --read-timeout=3600\ --connect-timeout=20\ --dns-timeout=20\ --retry-connrefused\ --retry-dns-error\ --max-redirect=128\ --phantomjs-scroll=50000\ --phantomjs-exe=/phantomjs-1.9.8-linux-x86_64/bin/phantomjs\ --content-on-error "$@"; }
#oq() { cd /home/grabbot/grabs/ && grab-site --no-dupespotter --concurrency=5 --wpull-args=--warc-move=/home/grabbot/warcdealer/\ --read-timeout=3600\ --connect-timeout=20\ --dns-timeout=20\ --retry-connrefused\ --retry-dns-error\ --max-redirect=128\ --phantomjs-scroll=50000\ --phantomjs-exe=/phantomjs-1.9.8-linux-x86_64/bin/phantomjs\ --content-on-error --1 "$@"; }
#ap() { cd /home/grabbot/grabs/ && grab-site --no-dupespotter --concurrency=5 --wpull-args=--warc-move=/home/grabbot/warcdealer/\ --read-timeout=3600\ --connect-timeout=20\ --dns-timeout=20\ --retry-connrefused\ --retry-dns-error\ --max-redirect=128\ --phantomjs-scroll=50000\ --phantomjs-exe=/phantomjs-1.9.8-linux-x86_64/bin/phantomjs\ --content-on-error\ --tries=1024\ --phantomjs "$@"; }
#op() { cd /home/grabbot/grabs/ && grab-site --no-dupespotter --concurrency=5 --wpull-args=--warc-move=/home/grabbot/warcdealer/\ --read-timeout=3600\ --connect-timeout=20\ --dns-timeout=20\ --retry-connrefused\ --retry-dns-error\ --max-redirect=128\ --phantomjs-scroll=50000\ --phantomjs-exe=/phantomjs-1.9.8-linux-x86_64/bin/phantomjs\ --content-on-error\ --tries=1024\ --phantomjs --1 "$@"; }

urlencode() {
    local LANG=C
    for ((i=0; i < ${#1}; i++)); do
        if [[ ${1:$i:1} =~ ^[a-zA-Z0-9\.\~_-]$ ]]; then
            printf '%s' "${1:$i:1}"
        else
            printf '%%%02X' "'${1:$i:1}"
        fi
    done
}

urldecode() {
    local url_encoded="${1//+/ }"
    printf '%b' "${url_encoded//%/\\x}"
}

isSubdirOf() {
    possibleEnclosingDir="$(readlink -f "$1")"
    possibleSubdir="$(readlink -f "$2")"
    if [[ "${possibleSubdir##$possibleEnclosingDir}" != "$possibleSubdir" ]]; then
        # This is a subdirectory
        return 0
    else
        return 1
    fi
}

contains() {
    local e
    for e in "${@:2}"; do [[ "$e" == "$1" ]] && return 0; done
    return 1
}

allElementsEqual() {
    local e
    for e in "${@:2}"; do [[ "$e" == "$1" ]] || return 1; done
    return 0
}

join_by() {
    # from https://stackoverflow.com/questions/1527049/join-elements-of-an-array
    local d="$1"
    shift
    echo -n "$1"
    shift
    printf "%s" "${@/#/$d}"
}

pipecheck() {
    allElementsEqual "0" "$@" || die "A failure status was reported by a call to pipecheck, with the reported exit statuses $(join_by ", " "$@")"
}

retryUntilSuccess() (
    local numberRegex='^[0-9]+$'
    local maximumRetries=-1
    if [[ "$1" =~ $numberRegex ]]; then
        maximumRetries="$1"
        shift
    fi
    local maximumDelayTime=0
    if [[ "$1" =~ $numberRegex ]]; then
        maximumDelayTime="$1"
        shift
    fi
    local delayTimeBackoffIncrement=1
    if [[ "$1" =~ $numberRegex ]]; then
        delayTimeBackoffIncrement="$1"
        shift
    fi
    local retryDelayTime=0
    if [[ "$1" =~ $numberRegex ]]; then
        # This sets the initial delay time
        retryDelayTime="$1"
        shift
    fi
    local currentRetries="$maximumRetries"
    local postExecCheckSuccess=""
    postExecCheckFailHandler() {
        if [[ -z "$postExecCheckSuccess" ]] || [[ "$postExecCheckSuccess" == "1" ]]; then
            postExecCheckSuccess="1"
        else
            postExecCheckSuccess="0"
        fi
    }
    until [[ "$currentRetries" -eq "0" ]]; do
        if "$@"; then
            postExecCheckFailHandler
            break
        fi
        if [[ "$currentRetries" != "0" ]]; then
            currentRetries=$((currentRetries-1))
        fi
        sleep "$retryDelayTime"
        if [[ "$retryDelayTime" -lt "$maximumDelayTime" ]]; then
            retryDelayTime=$((retryDelayTime + delayTimeBackoffIncrement))
        fi
    done
    [[ "$postExecCheckSuccess" != "1" ]] && die "Number of allowed retries exceeded without success."
    true # needed because the if statement executes with the exit status of the last command executed
)

findso() {
    # based on https://unix.stackexchange.com/questions/22178/which-equivalent-for-shared-libraries
    if [[ "$1" == "--plain" ]]; then
        soname="$2"
    else
        soname="lib${1}.so"
    fi
    local ldpath="$LD_LIBRARY_PATH"
    local found="false"
    if [[ -z "$ldpath" ]]; then
        ldpath="$(</etc/ld.so.conf)"
    else
        local IFS=:
    fi
    for libdir in $ldpath; do
        if [[ -f "$libdir/$soname" ]]; then
            echo "$libdir/$soname"
            found="true"
            break
        fi
    done
    if [[ "$found" == "true" ]]; then
        return 0
    fi
    /sbin/ldconfig -p | awk -v needle="$1" '$1 == needle {sub(/.* => /, ""); print}'
}

normalizeWhitespace() {
    # BROKEN: doesn't exit (when run with blah as its string)
    stdbuf -o0 tr '\n' ' ' | stdbuf -o0 tr '\r' ' ' | stdbuf -o0 tr -s '[:blank:]' | awk '{$1=$1};1'
}

flacToWaveform() {
    sourceFile="$1"
    destinationFile="$1.png"
    tempWavFile="$(tempFile)"
    tempPngFile="$(tempFile)"
    tempWorkDirectory="$(tempDir)"
    ffmpeg -v 0 -analyzeduration 900000000000 -probesize 200M  -threads 2 -i "$1" -ac 1 -ar 44100 -y "$tempWavFile" > /dev/null 2>&1
    (
        cd "$tempWorkDirectory" || die
        wav2png.py "$tempWavFile" > /dev/null 2>&1
    )
    convert -background black "$tempWorkDirectory"/tmp.png -gravity center -extent 800x200 -background black -fuzz 50% -transparent white "$tempPngFile"
    mv "$tempPngFile" "$destinationFile"
}

invertReturnValue() {
    if bash -c "$(join_by ' ' "$@")"; then
        return 1
    else
        return 0
    fi
}

getSystemTempLocation() {
    dirname "$(mktemp tmp.XXXXXXXXXX -ut)"
}

bigTempDir() {
    local tempLocation="$EMBER_TEMPDIR"
    [[ -n "$tempLocation" ]] && tempLocation="$(ember-getconf WorkDirectory)"
    [[ -n "$tempLocation" ]] && tempLocation="$(getSystemTempLocation)"
    local directoryId
    directoryId="$tempLocation/.tempDir-$(date-uuid)/"
    mkdir -p "$directoryId"
    echo "$directoryId"
}

bigTempFile() {
    local tempLocation="$EMBER_TEMPDIR"
    [[ -n "$tempLocation" ]] && tempLocation="$(ember-getconf WorkDirectory)"
    [[ -n "$tempLocation" ]] && tempLocation="$(getSystemTempLocation)"
    local fileId
    fileId="$tempLocation/.tempFile-$(date-uuid)"
    touch "$fileId"
    echo "$fileId"
}

tempDir() {
    mktemp -d ".tempFile-$(date-uuid).XXXXXXXXXX"
}

tempFile() {
    mktemp ".tempFile-$(date-uuid).XXXXXXXXXX"
}

crystallize-getconf() {
    [[ -n "$EmberWorkdirOverride54ae685dc782437c99bc46c7a1211377" ]] && export EmberWorkdirOverride54ae685dc782437c99bc46c7a1211377
    command crystallize-getconf "$@"
}

git-sync() {
    repo="$1"
    repoName="$(basename "$repo")"
    repoName="${repoName%.*}"
    if [[ -n "$repoName" ]]; then
        if [[ -e "$repoName.git" ]]; then
            [[ -d "$repoName.git" ]] || die "$(pwd)/$repoName.git does not seem to be a directory."
            (
                cd "$repoName.git" || die "Could not cd to repository directory $(pwd)/$repoName.git."
                echo "Updating clone of the \"$repoName\" git repository..."
                git fetch --all || die
            )
        else
            git clone --mirror "$repo" || die
        fi
    fi
}

git-bulk-sync() {
    while read -r repo; do
        git-sync "$repo"
    done
}

sponge() (
    trap 'error-notify "An error was reported in the sponge wrapper with the arguments $* on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR
    trap - EXIT
    local tempLocation="$EMBER_TEMPDIR"
    [[ -n "$tempLocation" ]] && tempLocation="$(ember-getconf WorkDirectory)"
    [[ -n "$tempLocation" ]] && tempLocation="$(getSystemTempLocation)"
    local oldTmpdir="$TMPDIR"
    TMPDIR="$tempLocation"
    export TMPDIR
    command sponge "$@"
)

checkedxz() (
    checkedxzErr() {
        rm -f "$output"
        rm -f "${streamingInput:?}"
    }
    trap 'checkedxzErr; die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR
    trap - EXIT
    local quiet="false"
    local requestWaitAfter="false"
    if [[ "$1" == "--quiet" ]]; then
        quiet="true"
        pv() {
            cat
        }
        shift
    elif [[ "$1" == "--request-wait-after" ]]; then
        requestWaitAfter="true"
        shift
    fi
    local input="$1"
    local useStdout=""
    if [[ -n "$input" ]]; then
        shift
        if [[ "$1" == "--stdout" ]]; then
            useStdout="true"
            shift
        fi
    else
        useStdout="true"
    fi

    local output
    output="$(bigTempFile)"
    local fileSize
    local execMode=""
    [[ "$quiet" != "true" ]] && echo "Packing..." >&2
    if [[ -z "$input" ]] || [[ "$input" == "-" ]]; then
        execMode="stdin"
        if [[ "$input" == "-" ]]; then
            useStdout="true"
        fi
        input="$(bigTempFile)"
        streamingInput="$(bigTempFile)"
        cat > "${input:?}"
        fileSize="$(disk-size-in-bytes "$input")"
        inputCsum="$(sha512sum "$input" | awk '{print $1;}')"
    else
        execMode="file"
        fileSize="$(disk-size-in-bytes "$input")"
        inputCsum="$(sha512sum "$input" | awk '{print $1;}')"
    fi
    checkedxzInner() (
        if [[ "$execMode" == "stdin" ]]; then
            pv -tparbIfei 0.1 -s "$fileSize" < "$input" | xz "$@" --stdout - > "$output"
        else
            xz -k "$@" --stdout "$input" | pv -tparbIfei 0.1 -s "$fileSize" > "$output"
        fi
        fileSize="$(disk-size-in-bytes "$output")"
        [[ "$quiet" != "true" ]] && echo "Checking..." >&2
        testOutputCsum="$(pv -tparbIfei 0.1 -s "$fileSize" < "$output" | unxz --stdout - | sha512sum | awk '{print $1;}')"
        [[ "$requestWaitAfter" == "true" ]] && echo "Please wait..." >&2
        assert equals "$inputCsum" "$testOutputCsum" || die
    )
    retryUntilSuccess 100 checkedxzInner "$@" || { [[ "$execMode" == "stdin" ]] && rm -f "${input:?}"; die; }
    if [[ "$useStdout" == "true" ]]; then
        cat "$output"
        rm "$output"
    else
        mv "$output" "$input.xz"
    fi
    if { ! contains "-k" "$@"; } || [[ "$execMode" == "stdin" ]]; then
        rm "${input:?}"
    fi
    if [[ -n "$streamingInput" ]]; then
        rm "$streamingInput"
    fi
)

# Test framework
{
    assert() {
        local save_traps
        save_traps="$(trap)"
        trap 'die "Error during assertion test: $(join_by ", " "$@") '"on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."'"' ERR
        local verbose=""
        if [[ "$1" == "-v" ]]; then
            verbose="true"
            shift
        elif [[ "$emberSharedAssertInheritVerbose" == "true" ]]; then
            verbose="true"
        fi
        local assertionTest="$1"
        shift

        case $assertionTest in
        directoryEquals)
            # trap is workaround for what I think is https://lists.gnu.org/archive/html/bug-bash/2016-02/msg00140.html
            trap 'die "Error during assertion test: $(join_by ", " "$@") '"on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."'"' ERR
            firstDir="$1"
            secondDir="$2"
            if [[ -z "$firstDir" ]] || [[ -z "$secondDir" ]]; then
                die "Both values must be non-empty."
            fi
            if [[ "$verbose" == "true" ]]; then
                # || die is workaround for what I think is https://lists.gnu.org/archive/html/bug-bash/2016-02/msg00140.html
                diff -uraN "$firstDir" "$secondDir" || die "Assertion failed: $(join_by ", " "$@") on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."
            else
                # || die is workaround for what I think is https://lists.gnu.org/archive/html/bug-bash/2016-02/msg00140.html
                diff -uraN "$firstDir" "$secondDir" > /dev/null || die "Assertion failed: $(join_by ", " "$@") on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."
            fi
            ;;
        fileEquals)
            # trap is workaround for what I think is https://lists.gnu.org/archive/html/bug-bash/2016-02/msg00140.html
            trap 'die "Error during assertion test: $(join_by ", " "$@") '"on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."'"' ERR
            firstFile="$1"
            secondFile="$2"
            if [[ -z "$firstFile" ]] || [[ -z "$secondFile" ]]; then
                die "Both values must be non-empty."
            fi
            # || die is workaround for what I think is https://lists.gnu.org/archive/html/bug-bash/2016-02/msg00140.html
            assert equals "$(sha512sum "$firstFile" | awk '{print $1;}')" "$(sha512sum "$secondFile" | awk '{print $1;}')" || die "Assertion failed: $(join_by ", " "$@") on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."
            ;;
        equals)
            # trap is workaround for what I think is https://lists.gnu.org/archive/html/bug-bash/2016-02/msg00140.html
            trap 'die "Error during assertion test: $(join_by ", " "$@") '"on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."'"' ERR
            # || die is workaround for what I think is https://lists.gnu.org/archive/html/bug-bash/2016-02/msg00140.html
            [[ "${1:?}" == "${2:?}" ]] || die "Assertion failed: $(join_by ", " "$@") on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."
            ;;
        true)
            trap 'die "Error during assertion test: $(join_by ", " "$@") '"on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."'"' ERR
            bash -c 'source ember_bash_setup &> /dev/null; '"$(join_by ' ' "$@")"
            ;;
        false)
            trap 'die "Error during assertion test: $(join_by ", " "$@") '"on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."'"' ERR
            invertReturnValue bash -c "$(join_by ' ' "$@")"
            ;;
        matches_regex)
            [[ "$1" =~ $2 ]]
            ;;
        *)
            trap 'error-notify "An error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR
            die "Unknown test."
            ;;
        esac
        eval "$save_traps"
    }

    passedTests="0"
    failedTests="0"
    totalTests="0"

    verboseTests=""

    runTest() {
        # This assumes that the test is a function, an external program, or a folder containing "exec" script. To force using an external program, use ./
        local verbose="$verboseTests"
        if [[ "$1" == "-v" ]]; then
            verbose="true"
            shift
        fi
        emberSharedAssertInheritVerbose=""
        if [[ "$1" == "-vv" ]]; then
            verbose="true"
            emberSharedAssertInheritVerbose="true"
            export emberSharedAssertInheritVerbose
            shift
        fi
        totalTests=$(( totalTests + 1 ))
        local testName="$1"
        shift
        testPass() {
            echo "Test $testName passed."
            passedTests=$(( passedTests + 1 ))
        }
        testFail() {
            echo "Test $testName failed."
            failedTests=$(( failedTests + 1 ))
        }
        local digitsRegex='^[0-9]+$'
        if [[ -d "$testName" ]]; then
            pushd "$testName" > /dev/null || die
            chmod +x ./exec
            if [[ "$verbose" == "true" ]]; then
                if ./exec "$@"; then
                    testPass
                else
                    testFail
                fi
            else
                if ./exec "$@" &> /dev/null; then
                    testPass
                else
                    testFail
                fi
            fi
            popd > /dev/null || die
        elif [[ -f "$testName" ]]; then
            # The test is a file to run. If you want to test a function but its name is also used by a file, wrap it in braces (like: { foo }).
            chmod +x ./"$testName"
            if [[ "$verbose" == "true" ]]; then
                if ./"$testName" "$@"; then
                    testPass
                else
                    testFail
                fi
            else
                if ./"$testName" "$@" &> /dev/null; then
                    testPass
                else
                    testFail
                fi
            fi
        elif type -t "$testName" > /dev/null; then
            # The test is a function or command name.
            if [[ "$verbose" == "true" ]]; then
                if "$testName" "$@"; then
                    testPass
                else
                    testFail
                fi
            else
                if "$testName" "$@" &> /dev/null; then
                    testPass
                else
                    testFail
                fi
            fi
         elif [[ "$testName" =~ $digitsRegex ]]; then
            # The test is an inline function like runTest { assert blah }, so all we have to do here is check the status code
            if [[ "$testName" == "0" ]]; then
                testPass
            else
                testFail
            fi
        else
            warn "Could not find the test $testName."
            testFail
        fi
    }

    reportTests() {
        local passedWord="tests"
        if [[ "$passedTests" == 1 ]]; then
            passedWord="test"
        fi
        local failedWord="tests"
        if [[ "$failedTests" == 1 ]]; then
            failedWord="test"
        fi
        local totalWord="tests"
        if [[ "$totalTests" == 1 ]]; then
            totalWord="test"
        fi
        passedPercentage="$(printf "%.3f\\n" "$(bc -l <<< "($passedTests / $totalTests) * 100")")"
        failedPercentage="$(printf "%.3f\\n" "$(bc -l <<< "($failedTests / $totalTests) * 100")")"
        echo "$passedTests $passedWord ($passedPercentage%) passed and $failedTests $failedWord ($failedPercentage%) failed out of a total of $totalTests $totalWord."
        if [[ "$failedTests" != "0" ]]; then
            totalWord="Some tests"
            if [[ "$totalTests" == 1 ]]; then
                totalWord="A test"
            fi
            error-notify "$totalWord ($failedPercentage%: $failedTests out of $totalTests) failed!"
        fi
        [[ $(( totalTests - failedTests )) == "$passedTests" ]] || die "There's a problem in the testing framework."
    }
}

trap 'error-notify "An error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR
